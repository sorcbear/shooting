<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="format-detection" content="telephone=no,address=no,email=no">
  <title>Finger Air Rifle</title>

  <style>
    html,body{margin:0;height:100%;background:#fff;overflow:hidden}
    #app{position:fixed; inset:0; display:flex; flex-direction:column; background:#fff;}
    #leftPane{
      position:relative; flex:0 0 66.6667%; min-height:0;
      background:#fff; overflow:hidden;
    }
    #rightPane{
      position:relative; flex:0 0 33.3333%; min-height:0;
      background:#fff; border-top:1px solid #eee;
      overflow:hidden; display:flex; flex-direction:column;
      padding:12px; gap:10px; box-sizing:border-box;
    }
    @media (orientation: landscape){
      #app{flex-direction:row;}
      #leftPane{flex:0 0 66.6667%; height:100vh;}
      #rightPane{
        flex:0 0 33.3333%; height:100vh;
        border-top:none; border-left:1px solid #eee;
      }
    }

    /* âœ… æ‘„åƒå¤´ç”»é¢ï¼šåå°è·‘ï¼Œä½†å‰ç«¯ä¸æ˜¾ç¤ºï¼ˆä¸å½±å“ MediaPipe è¾“å…¥ï¼‰ */
    #video{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit:cover; transform:scaleX(-1) translateZ(0);
      will-change: transform;
      backface-visibility: hidden;
      z-index:0;
      background:#000;
      opacity:0;                 /* âœ… æ°¸è¿œéšè— */
      pointer-events:none;       /* âœ… ä¸æŒ¡äº¤äº’ */
      transition:none;           /* âœ… é¿å…é—ªçƒ */
    }
    #cv{
      position:absolute; inset:0; width:100%; height:100%;
      touch-action:none; z-index:1;
      transform: translateZ(0);
      will-change: transform;
    }

    #hud{
      font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#111;background:rgba(255,255,255,.96);
      border:1px solid #ddd;border-radius:12px;padding:10px 12px;
      display:flex;gap:10px;flex-wrap:wrap;align-items:center
    }
    #hud b{font-size:15px}
    #hud .muted{color:#666}
    #hud .pill{border:1px solid #111;border-radius:999px;padding:6px 10px;background:#fff;font-weight:800}
    #hint{ display:none; }

    #log{
      flex:1 1 auto; min-height:0;
      font:13px/1.35 ui-monospace,SFMono-Regular,Menlo,monospace;
      color:#111;background:rgba(255,255,255,.96);
      border:1px solid #ddd;border-radius:12px;padding:10px 12px;
      overflow:auto;white-space:pre-wrap
    }
    #flash{
      position:absolute; inset:0; z-index:2;
      background:#fff; opacity:0; pointer-events:none;
      transition:opacity 80ms linear;
    }
    #debugInfo{
      position:absolute; top:10px; left:10px; z-index:3;
      font:11px/1.3 ui-monospace,monospace;
      color:#000; background:rgba(255,255,255,0.9);
      border:1px solid #999; border-radius:6px;
      padding:8px; max-width:240px;
      display:none;
    }

    /* åˆ†äº«æŒ‰é’®ï¼ˆå³ä¸Šè§’ / ç›´è§’ / é»‘åº•ç™½å­— / ç™½è‰²åˆ†äº«ç®­å¤´ï¼‰ */
    #shareBtn{
      position:absolute; top:16px; right:16px; z-index:6;
      background:#000; color:#fff;
      border:1px solid rgba(255,255,255,0.18);
      border-radius:0;
      padding:10px 14px;
      font-size:15px; font-weight:700;
      cursor:pointer;
      box-shadow:0 4px 12px rgba(0,0,0,0.28);
      transition:transform 0.15s, background 0.15s, box-shadow 0.15s;
      display:flex; align-items:center; gap:8px;
      user-select:none;
    }
    #shareBtn:hover{
      background:#111;
      transform:translateY(-1px);
      box-shadow:0 6px 16px rgba(0,0,0,0.32);
    }
    #shareBtn:active{ transform:translateY(0); }
    #shareBtn::before{
      content:'';
      width:18px; height:18px;
      display:inline-block;
      background-repeat:no-repeat;
      background-size:contain;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='white' d='M16 8l-4-4-4 4h3v6h2V8h3z'/%3E%3Cpath fill='white' d='M5 14h2v5h10v-5h2v7H5v-7z'/%3E%3C/svg%3E");
    }

    /* æ¯10å‘ç§°å·å…¨å±å±•ç¤ºï¼ˆé»‘åº•ç™½å­—ï¼‰ */
    #celebration{
      position:absolute; inset:0; z-index:10;
      background:#000; color:#fff;
      display:none;
      align-items:center; justify-content:center;
      text-align:center;
      padding:24px;
      box-sizing:border-box;
      animation:fadeIn 0.18s ease-out;
    }
    #celebration.show{ display:flex; }
    @keyframes fadeIn{
      from{opacity:0; transform:scale(0.98);}
      to{opacity:1; transform:scale(1);}
    }
    #celebration .title{
      font:900 56px/1.1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      letter-spacing:0.5px;
      margin-bottom:14px;
    }
    #celebration .subtitle{
      font:700 22px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      opacity:0.88;
    }

    /* åˆ†äº«é¢„è§ˆå±‚ */
    #sharePreview{ position:absolute; inset:0; z-index:20; display:none; }
    #sharePreview.show{ display:block; }
    #sharePreview .sp-backdrop{ position:absolute; inset:0; background:rgba(0,0,0,0.55); }

    #sharePreview .sp-panel{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      width:min(92vw, 860px);
      max-height:92vh;
      background:#fff; color:#000;
      border:1px solid rgba(0,0,0,0.16);
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      display:flex; flex-direction:column;
      overflow:hidden;
    }
    #sharePreview .sp-top{
      flex:0 0 auto;
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      border-bottom:1px solid rgba(0,0,0,0.10);
      background:#fff;
    }
    #sharePreview .sp-title{
      color:#000;
      font:800 16px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    }
    #sharePreview .sp-close{
      appearance:none;
      background:#fff;
      border:1px solid rgba(0,0,0,0.18);
      color:#000;
      width:34px; height:34px;
      border-radius:0;
      font:900 22px/1 system-ui;
      cursor:pointer;
    }
    #sharePreview .sp-body{
      flex:1 1 auto;
      min-height:0;
      padding:12px;
      overflow:auto;
      background:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #sharePreview .sp-body img{
      display:block;
      width:100%;
      height:auto;
      max-height:100%;
      object-fit:contain;
      background:#000;
      border:1px solid rgba(0,0,0,0.12);
    }
    #sharePreview .sp-actions{
      flex:0 0 auto;
      display:flex;
      gap:10px;
      padding:12px 14px;
      border-top:1px solid rgba(0,0,0,0.10);
      justify-content:flex-end;
      background:#fff;
      padding-bottom:calc(12px + env(safe-area-inset-bottom));
    }
    #sharePreview .sp-btn{
      border-radius:0;
      padding:10px 14px;
      font:800 14px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      cursor:pointer;
      border:1px solid rgba(0,0,0,0.18);
      background:#fff;
      color:#000;
    }
    #sharePreview .sp-btn:hover{ background:#f3f3f3; }
    #sharePreview .sp-primary{
      background:#000; color:#fff; border-color:#000;
    }
    #sharePreview .sp-primary:hover{ background:#111; }

    @media (orientation: landscape), (max-height: 520px){
      #sharePreview .sp-panel{
        left:12px; right:12px; top:12px; bottom:12px;
        transform:none;
        width:auto;
        max-height:none;
      }
    }

    /* âœ… å¼€å§‹é¡µ */
    #startGate{
      position:absolute; inset:0; z-index:30;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:space-between;
      background:#fff;
      padding:18px;
      padding-top:calc(6px + env(safe-area-inset-top));
      padding-bottom:calc(20px + env(safe-area-inset-bottom));
      box-sizing:border-box;
    }

    #gateImgWrap{
      width:min(920px, 96vw);
      flex:1 1 auto;
      min-height:0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #gateImg{
      display:block;
      width:100%;
      height:auto;
      max-height:100%;
      object-fit:contain;
    }

    #gateBtn{
      width:240px;
      height:60px;
      border-radius:0;
      border:2px solid #000;
      background:#fff;
      color:#000;
      cursor:pointer;
      padding:8px 12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:4px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      user-select:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
      flex:0 0 auto;
    }
    #gateBtn .line1{ font-weight:900; font-size:20px; line-height:1; }
    #gateBtn .line2{ font-weight:800; font-size:13px; line-height:1; opacity:0.85; }
    #gateBtn:hover{ background:#000; color:#fff; }
    #gateBtn:disabled{ opacity:0.75; cursor:default; }
  </style>
</head>

<body>
  <div id="app">
    <div id="leftPane">
      <video id="video" playsinline muted></video>
      <canvas id="cv"></canvas>
      <div id="flash"></div>
      <div id="debugInfo"></div>

      <button id="shareBtn">åˆ†äº«æˆç»©</button>

      <div id="celebration">
        <div>
          <div class="title" id="celeTitle">å¥¥è¿å† å†›</div>
          <div class="subtitle" id="celeSub">10å‘æ€»åˆ† 105.0</div>
        </div>
      </div>

      <div id="sharePreview" aria-hidden="true">
        <div class="sp-backdrop"></div>
        <div class="sp-panel" role="dialog" aria-modal="true">
          <div class="sp-top">
            <div class="sp-title">åˆ†äº«å›¾ç‰‡é¢„è§ˆ</div>
            <button class="sp-close" id="spClose" aria-label="å…³é—­é¢„è§ˆ">Ã—</button>
          </div>
          <div class="sp-body">
            <img id="spImg" alt="æˆç»©åˆ†äº«å›¾é¢„è§ˆ" />
          </div>
          <div class="sp-actions">
            <button class="sp-btn" id="spBack">è¿”å›</button>
            <button class="sp-btn sp-primary" id="spDownload">ä¸‹è½½</button>
          </div>
        </div>
      </div>

      <div id="startGate">
        <div id="gateImgWrap">
          <img id="gateImg" src="start-guide.png" alt="å·¦æ‰‹ç„å‡†ï¼Œå³æ‰‹å‡»å‘" />
        </div>
        <button id="gateBtn">
          <div class="line1">å¼€å§‹å°„å‡»</div>
          <div class="line2">å¯å¼€å¯å£°éŸ³ï¼Œå»ºè®®æ¨ªå±</div>
          <div class="line2">è·ç¦»å±å¹•è‡³å°‘50cm</div>
        </button>
      </div>
    </div>

    <div id="rightPane">
      <div id="hud">
        <div><b>Finger Air Rifle</b></div>
        <div><span class="muted">å·¦æ‰‹æ‰‹æŒç„å‡† Â· å³æ‰‹æåˆå‡»å‘</span></div>
        <span id="status" class="pill">åˆå§‹åŒ–â€¦</span>
        <span class="muted" id="hint"></span>
      </div>
      <div id="log"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
    // DOM
    const leftPane = document.getElementById('leftPane');
    const video = document.getElementById('video');
    const canvas = document.getElementById('cv');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const flashEl = document.getElementById('flash');
    const hintEl = document.getElementById('hint');
    const debugInfo = document.getElementById('debugInfo');
    const shareBtn = document.getElementById('shareBtn');

    const celebration = document.getElementById('celebration');
    const celeTitle = document.getElementById('celeTitle');
    const celeSub = document.getElementById('celeSub');

    // Share preview DOM
    const sharePreview = document.getElementById('sharePreview');
    const spImg = document.getElementById('spImg');
    const spClose = document.getElementById('spClose');
    const spBack = document.getElementById('spBack');
    const spDownload = document.getElementById('spDownload');
    let spBlobUrl = null;
    let spDownloadName = '';

    // Start gate DOM
    const startGate = document.getElementById('startGate');
    const gateBtn = document.getElementById('gateBtn');

    // Debug
    const DEBUG_MODE = false;
    if(DEBUG_MODE) debugInfo.style.display = 'block';

    // Modes
    const MODE = { WAIT_BOTH:'WAIT_BOTH', READY:'READY', PLAY:'PLAY' };
    let mode = MODE.WAIT_BOTH;

    // Canvas size
    let W=0,H=0,DPR=1,cx=0,cy=0;
    let rectW=0, rectH=0, shortCss=0;

    function isIPhoneLike(){
      const ua = navigator.userAgent || '';
      const isiPhone = /iPhone/.test(ua);
      const isiPad = /iPad/.test(ua) || (/Macintosh/.test(ua) && /Mobile/.test(ua));
      if(isiPhone) return true;
      if(isiPad) return false;
      return shortCss < 520;
    }
    function isLandscape(){ return rectW > rectH; }

    // Aim
    let aimX=null, aimY=null;
    let followAlpha = 0.97;
    let sensitivity = 2.4;

    // Trigger icon position
    let trigX=null, trigY=null;
    let trigFollowAlpha = 0.55;

    // ä¿æŒæ˜¾ç¤ºï¼Œé˜²é—ª
    const HOLD_MS = 800;
    let lastAimSeenTs = 0;
    let lastTrigSeenTs = 0;

    function tuneAimByDevice(){
      const phone = isIPhoneLike();
      followAlpha = phone ? 1 : 1;

      const REF_SHORT = 390;
      const baseGainPhone = 10;
      const baseGainPad   = 8;
      const base = phone ? baseGainPhone : baseGainPad;

      let gain = base * (REF_SHORT / Math.max(1, shortCss));
      sensitivity = Math.min(14, Math.max(1.1, gain));
    }

    function resize(){
      DPR = Math.max(1, window.devicePixelRatio || 1);

      const rect = leftPane.getBoundingClientRect();
      rectW = rect.width;
      rectH = rect.height;
      shortCss = Math.max(1, Math.min(rectW, rectH));

      W = Math.max(1, Math.floor(rectW * DPR));
      H = Math.max(1, Math.floor(rectH * DPR));

      canvas.width = W; canvas.height = H;
      canvas.style.width = rectW+'px';
      canvas.style.height = rectH+'px';

      cx = W/2; cy = H/2;

      tuneAimByDevice();
    }

    function resizeTwice(){
      resize();
      requestAnimationFrame(()=>resize());
      setTimeout(()=>resize(), 120);
    }

    addEventListener('resize', resizeTwice);
    addEventListener('orientationchange', ()=>setTimeout(resizeTwice, 150));
    resizeTwice();

    // Video readiness
    let videoReady = false;
    function updateVideoReady(){
      videoReady = (video.readyState >= 2) && (video.videoWidth > 0) && (video.videoHeight > 0);
      return videoReady;
    }

    function waitVideoReady(timeoutMs=9000){
      return new Promise((resolve, reject)=>{
        const t0 = Date.now();
        const tick = ()=>{
          updateVideoReady();
          if(videoReady) return resolve(true);
          if(Date.now() - t0 > timeoutMs) return reject(new Error('VideoReadyTimeout'));
          setTimeout(tick, 80);
        };
        tick();
      });
    }

    // State flags
    let firstShotDone = false;
    let lockReady = false;

    // Target / sight
    const targetSquareHalf = 110;
    const targetDotR = 22;
    const sight_outer_r = 120;
    const sight_inner_r = 44;

    // Freeze
    const FREEZE_MS = 220;
    let freezeUntil = 0;
    let freezeAimX = null, freezeAimY = null;

    // Lock for calibration phase ONLY
    const LOCK_DIST_PX = 38;
    const LOCK_FRAMES_NEED = 24;
    let lockFrames = 0;

    // Score
    const CENTER_SCORE = 10.9;
    const TOUCH_SCORE  = 6.0;

    function scoreFromAimPos(aimX_px, aimY_px){
      const d = Math.hypot(aimX_px - cx, aimY_px - cy);
      const Rb  = targetDotR * DPR;
      const Rin = sight_inner_r * DPR;
      const d_ref = Math.max(1e-6, Rin - Rb);
      const dropAtRef = (CENTER_SCORE - TOUCH_SCORE);
      const constant = d_ref / dropAtRef;
      let score = CENTER_SCORE - (d / constant);
      score = Math.max(0, Math.min(CENTER_SCORE, score));
      return Math.round(score * 10) / 10;
    }

    function titleByTenSum(sum){
      if(sum < 90)  return 'å»ºè®®æˆªè‚¢';
      if(sum < 97)  return 'ç”¨è„šæ‰“çš„ï¼Ÿ';
      if(sum < 100) return 'ä¸€èˆ¬èˆ¬å§';
      if(sum < 102) return 'æœ‰ç‚¹äººæ ·äº†';
      if(sum < 105) return 'æœ‰æœ›å†²å‡»å¥¥è¿';
      if(sum < 106) return 'å¥¥è¿æ°´å‡†ï¼';
      if(sum < 109) return 'å¥¥è¿å† å†›ï¼ï¼';
      return 'å¥¥è¿å† å†›';
    }

    // Scores
    let shotScores = [];
    let lastTenShownEnd = 0;

    function showTenTitle(sum){
      celeTitle.textContent = titleByTenSum(sum);
      celeSub.textContent = `10å‘æ€»åˆ† ${sum.toFixed(1)}`;
      celebration.classList.add('show');
      setTimeout(()=>celebration.classList.remove('show'), 5000);
    }

    function renderScores(){
      const n = shotScores.length;
      if(n === 0){
        logEl.textContent = '';
        return;
      }

      let out = '';
      const groups = Math.ceil(n / 10);

      for(let g = groups - 1; g >= 0; g--){
        const start = g * 10;
        const end = Math.min(n, start + 10);

        let sum = 0;
        for(let i = start; i < end; i++) sum += shotScores[i];

        out += `Total(${start+1}-${end}): ${sum.toFixed(1)}\n`;

        if((end - start) === 10 && end > lastTenShownEnd){
          lastTenShownEnd = end;
          showTenTitle(sum);
        }

        for(let i = end - 1; i >= start; i--){
          out += `${i+1}.  ${shotScores[i].toFixed(1)}\n`;
        }
        out += '\n';
      }

      logEl.textContent = out.trim();
      logEl.scrollTop = 0;
    }

    // Utils
    const ema = (prev,next,a)=> prev + (next-prev)*a;

    function mapToScreen(nx, ny){
      let x = nx, y = ny;
      x = 1 - x; // mirror
      let px = x * W;
      let py = y * H;
      px = cx + (px - cx) * sensitivity;
      py = cy + (py - cy) * sensitivity;
      return {px,py};
    }

    function haveRecent(ts){ return (Date.now() - ts) < HOLD_MS; }

    // Draw target
    function drawTarget(){
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,W,H);

      const half = targetSquareHalf * DPR;
      ctx.fillStyle = '#fff';
      ctx.fillRect(cx-half, cy-half, 2*half, 2*half);

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 4 * DPR;
      ctx.strokeRect(cx-half, cy-half, 2*half, 2*half);

      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(cx, cy, targetDotR * DPR, 0, Math.PI*2);
      ctx.fill();
    }

    function drawSight(x,y){
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 28*DPR;
      ctx.beginPath();
      ctx.arc(x,y, sight_outer_r*DPR, 0, Math.PI*2);
      ctx.stroke();

      const rOuter = (sight_outer_r - 14)*DPR;
      const barW = 8*DPR;
      ctx.fillStyle = '#000';
      ctx.fillRect(x-rOuter-20*DPR, y-barW/2, 20*DPR, barW);
      ctx.fillRect(x+rOuter,        y-barW/2, 20*DPR, barW);

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 14*DPR;
      ctx.beginPath();
      ctx.arc(x,y, sight_inner_r*DPR, 0, Math.PI*2);
      ctx.stroke();
    }

    // âœ… é»‘ç™½â€œæ‰³æœºâ€ç¬¦å·
    function drawTriggerIcon(x, y){
      const s = 36 * DPR;

      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      const x0 = x - s*0.30;
      const y0 = y - s*0.10;

      function strokePath(w, color){
        ctx.lineWidth = w;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(x0, y0 - s*0.35);
        ctx.lineTo(x0, y0 + s*0.30);
        ctx.lineTo(x0 + s*0.50, y0 + s*0.30);
        ctx.lineTo(x0 + s*0.50, y0 + s*0.55);
        ctx.stroke();
      }

      strokePath(10*DPR, '#fff');
      strokePath(6*DPR,  '#000');

      ctx.restore();
    }

    // âœ… æç¤ºæ–‡å­—ï¼ˆåœ¨æ­£æ–¹å½¢ä¸‹é¢ + ç¨³å®šåˆ‡æ¢ï¼Œé˜²é—ªï¼‰
    let overlayMsg = '';
    let overlayWanted = '';
    let overlayStable = 0;
    const OVERLAY_STABLE_FRAMES = 10;

    function wantOverlayMessage(haveAimRecent, haveTrigRecent, haveSightRecent){
      if(!videoReady) return 'ç­‰å¾…æ‘„åƒå¤´ç”»é¢â€¦';

      // æ ¡å‡†å‰ï¼šæ°¸ä¸æ¶ˆå¤±
      if(!firstShotDone){
        if(!haveAimRecent || !haveTrigRecent || !haveSightRecent){
          return 'åŒæ‰‹è·ç¦»å±å¹•50cmä»¥ä¸Š\nç§»åŠ¨ä½ç½®ï¼Œç›´åˆ°å±å¹•ä¸Šå‡ºç°ç„å‡†å™¨';
        }
        if(!lockReady) return 'è¯·å¯¹å‡†é¶å¿ƒä¿æŒä¸€ä¸‹';
        return 'å·²é”å®š âœ…\næåˆå‡»å‘æ ¡å‡†';
      }

      // æ ¡å‡†åï¼šåŒæ‰‹éƒ½åœ¨ -> ä¸æ˜¾ç¤ºï¼›ç¼ºä¸€åª -> æ˜¾ç¤º
      if(!haveAimRecent || !haveTrigRecent || !haveSightRecent){
        return 'åŒæ‰‹è·ç¦»å±å¹•50cmä»¥ä¸Š\nç§»åŠ¨ä½ç½®ï¼Œç›´åˆ°å±å¹•ä¸Šå‡ºç°ç„å‡†å™¨';
      }
      return '';
    }

    function updateOverlayStable(haveAimRecent, haveTrigRecent, haveSightRecent){
      const wanted = wantOverlayMessage(haveAimRecent, haveTrigRecent, haveSightRecent);

      if(wanted === overlayWanted) overlayStable++;
      else{ overlayWanted = wanted; overlayStable = 0; }

      if(overlayStable >= OVERLAY_STABLE_FRAMES){
        overlayMsg = overlayWanted;
      }

      // ä¿é™©ï¼šæ ¡å‡†å‰æ°¸ä¸ç©º
      if(!firstShotDone && overlayMsg === ''){
        overlayMsg = 'åŒæ‰‹è·ç¦»å±å¹•50cmä»¥ä¸Š\nç§»åŠ¨ä½ç½®ï¼Œç›´åˆ°å±å¹•ä¸Šå‡ºç°ç„å‡†å™¨';
      }
    }

    function envSafeBottomPx(){
      return (isIPhoneLike() && isLandscape()) ? (8*DPR) : 0;
    }

    function drawBottomMessage(lines){
      const half = targetSquareHalf * DPR;

      const minY = (cy + half) + 10*DPR;
      const maxY = H - (14*DPR + 12*DPR + envSafeBottomPx());
      if(maxY <= minY) return;

      const areaH = Math.max(1, maxY - minY);
      const maxW = Math.max(1, W - 24*DPR);

      const phone = isIPhoneLike();
      const land = isLandscape();

      const minFont = (phone && land) ? (34*DPR) : (26*DPR);
      const maxFont = Math.min(58*DPR, Math.round((2*half) * 0.20));
      let fontPx = Math.max(minFont, Math.min(maxFont, Math.round((2*half) * 0.18)));
      let lineH  = fontPx * 1.18;

      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      for(let iter=0; iter<18; iter++){
        ctx.font = `900 ${fontPx}px system-ui,-apple-system,Segoe UI,Roboto,sans-serif`;

        let maxTextW = 0;
        for(const t of lines) maxTextW = Math.max(maxTextW, ctx.measureText(t).width);

        const padX = 14*DPR;
        const padY = 10*DPR;

        const bw = Math.min(maxW, maxTextW + padX*2);
        const bh = lines.length*lineH + padY*2;

        if((maxTextW + padX*2) > maxW || bh > areaH){
          fontPx *= 0.90;
          lineH = fontPx * 1.18;
          continue;
        }

        const bx = cx - bw/2;
        const by = minY + (areaH - bh)/2;

        ctx.fillStyle = 'rgba(255,255,255,0.94)';
        ctx.fillRect(bx, by, bw, bh);

        ctx.fillStyle = '#000';
        for(let i=0;i<lines.length;i++){
          const yy = by + padY + lineH/2 + i*lineH;
          ctx.fillText(lines[i], cx, yy);
        }
        ctx.restore();
        return;
      }

      ctx.restore();
    }

    function drawGuideOverlay(haveAimRecent, haveTrigRecent, haveSightRecent){
      updateOverlayStable(haveAimRecent, haveTrigRecent, haveSightRecent);
      if(!overlayMsg) return;
      drawBottomMessage(overlayMsg.split('\n'));
    }

    function render(){
      drawTarget();

      const now = Date.now();

      const haveAimRecent  = haveRecent(lastAimSeenTs);
      const haveTrigRecent = haveRecent(lastTrigSeenTs);
      const haveSightRecent = haveAimRecent && (aimX!=null && aimY!=null);

      const fx = (now < freezeUntil && freezeAimX!=null) ? freezeAimX : aimX;
      const fy = (now < freezeUntil && freezeAimY!=null) ? freezeAimY : aimY;

      if(haveAimRecent && fx!=null) drawSight(fx, fy);
      if(haveTrigRecent && trigX!=null) drawTriggerIcon(trigX, trigY);

      drawGuideOverlay(haveAimRecent, haveTrigRecent, haveSightRecent);
    }

    // ============================================================
    // âœ…ã€å£°éŸ³ç³»ç»Ÿã€‘åŸæ ·ä¿ç•™
    // ============================================================
    let audioCtx = null;
    let audioEnabled = false;

    let preGain = null;
    let compressor = null;
    let limiter = null;

    let slapDelay = null;
    let slapFB = null;
    let slapMix = null;

    function ensureAudio(){
      if(audioCtx) return audioCtx;

      const AC = (window.AudioContext || window.webkitAudioContext);
      if(!AC) return null;

      audioCtx = new AC();

      preGain = audioCtx.createGain();
      preGain.gain.setValueAtTime(1.55, audioCtx.currentTime);

      compressor = audioCtx.createDynamicsCompressor();
      compressor.threshold.setValueAtTime(-22, audioCtx.currentTime);
      compressor.knee.setValueAtTime(16, audioCtx.currentTime);
      compressor.ratio.setValueAtTime(10, audioCtx.currentTime);
      compressor.attack.setValueAtTime(0.002, audioCtx.currentTime);
      compressor.release.setValueAtTime(0.16, audioCtx.currentTime);

      limiter = audioCtx.createDynamicsCompressor();
      limiter.threshold.setValueAtTime(-1.1, audioCtx.currentTime);
      limiter.knee.setValueAtTime(0, audioCtx.currentTime);
      limiter.ratio.setValueAtTime(20, audioCtx.currentTime);
      limiter.attack.setValueAtTime(0.001, audioCtx.currentTime);
      limiter.release.setValueAtTime(0.08, audioCtx.currentTime);

      slapDelay = audioCtx.createDelay(0.10);
      slapDelay.delayTime.setValueAtTime(0.030, audioCtx.currentTime);
      slapFB = audioCtx.createGain();
      slapFB.gain.setValueAtTime(0.18, audioCtx.currentTime);
      slapMix = audioCtx.createGain();
      slapMix.gain.setValueAtTime(0.22, audioCtx.currentTime);

      preGain.connect(slapDelay);
      slapDelay.connect(slapMix);
      slapMix.connect(compressor);

      slapDelay.connect(slapFB);
      slapFB.connect(slapDelay);

      preGain.connect(compressor);
      compressor.connect(limiter);
      limiter.connect(audioCtx.destination);

      return audioCtx;
    }

    async function enableAudio(){
      const ctx = ensureAudio();
      if(!ctx) throw new Error('NoAudioContext');
      if(ctx.state === 'suspended') await ctx.resume();
      audioEnabled = true;

      try{
        const t = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(40, t);
        g.gain.setValueAtTime(0.00001, t);
        o.connect(g); g.connect(preGain);
        o.start(t);
        o.stop(t + 0.03);
      }catch{}
    }

    function makeNoiseBuffer(dur){
      const ctx = audioCtx;
      const n = Math.floor(ctx.sampleRate * dur);
      const buf = ctx.createBuffer(1, n, ctx.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<n;i++){
        const x = i / n;
        const e = Math.pow(1 - x, 2.15);
        const punch = (x < 0.020) ? 2.25 : 1.0;
        data[i] = (Math.random()*2-1) * e * punch;
      }
      return buf;
    }

    function beep(){
      if(!audioEnabled || !audioCtx || !preGain) return;
      const ctx = audioCtx;
      const t0 = ctx.currentTime;

      try{
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(78, t0);
        o.frequency.exponentialRampToValueAtTime(42, t0 + 0.16);
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.linearRampToValueAtTime(1.05, t0 + 0.008);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);
        o.connect(g); g.connect(preGain);
        o.start(t0);
        o.stop(t0 + 0.26);
      }catch{}

      try{
        const dur = 0.32;
        const src = ctx.createBufferSource();
        src.buffer = makeNoiseBuffer(dur);

        const lp = ctx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.setValueAtTime(4200, t0);
        lp.frequency.exponentialRampToValueAtTime(700, t0 + dur);

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.linearRampToValueAtTime(1.15, t0 + 0.006);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        src.connect(lp); lp.connect(g); g.connect(preGain);
        src.start(t0);
        src.stop(t0 + dur + 0.03);
      }catch{}

      try{
        const dur = 0.08;
        const src = ctx.createBufferSource();
        src.buffer = makeNoiseBuffer(dur);

        const hp = ctx.createBiquadFilter();
        hp.type = 'highpass';
        hp.frequency.setValueAtTime(1400, t0);

        const bp = ctx.createBiquadFilter();
        bp.type = 'bandpass';
        bp.frequency.setValueAtTime(3200, t0);
        bp.Q.setValueAtTime(8.0, t0);

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.linearRampToValueAtTime(0.95, t0 + 0.004);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        src.connect(hp); hp.connect(bp); bp.connect(g); g.connect(preGain);
        src.start(t0);
        src.stop(t0 + dur + 0.02);
      }catch{}
    }

    // Share preview open/close
    function openSharePreview(blob){
      if(spBlobUrl){
        URL.revokeObjectURL(spBlobUrl);
        spBlobUrl = null;
      }
      spBlobUrl = URL.createObjectURL(blob);
      spDownloadName = `finger-rifle-${Date.now()}.png`;

      spImg.src = spBlobUrl;
      sharePreview.classList.add('show');
      sharePreview.setAttribute('aria-hidden','false');
    }

    function closeSharePreview(){
      sharePreview.classList.remove('show');
      sharePreview.setAttribute('aria-hidden','true');

      if(spBlobUrl){
        URL.revokeObjectURL(spBlobUrl);
        spBlobUrl = null;
      }
      spImg.src = '';
    }

    spClose.addEventListener('click', closeSharePreview);
    spBack.addEventListener('click', closeSharePreview);
    sharePreview.querySelector('.sp-backdrop').addEventListener('click', closeSharePreview);

    spDownload.addEventListener('click', ()=>{
      if(!spBlobUrl) return;
      const a = document.createElement('a');
      a.href = spBlobUrl;
      a.download = spDownloadName || `finger-rifle-${Date.now()}.png`;
      a.click();
    });

    async function shareScore(){
      try{
        const shareCanvas = document.createElement('canvas');
        const shareCtx = shareCanvas.getContext('2d');

        const width = 1200;
        const height = 630;
        shareCanvas.width = width;
        shareCanvas.height = height;

        shareCtx.fillStyle = '#000';
        shareCtx.fillRect(0, 0, width, height);

        shareCtx.fillStyle = '#fff';
        shareCtx.font = '900 60px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
        shareCtx.textAlign = 'center';
        shareCtx.fillText('ğŸ¯ Air Finger Rifle', width/2, 100);

        shareCtx.fillStyle = 'rgba(255,255,255,0.95)';
        shareCtx.fillRect(100, 150, width-200, height-200);

        shareCtx.fillStyle = '#333';
        shareCtx.font = '800 32px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
        shareCtx.textAlign = 'left';

        const n = shotScores.length;
        if(n === 0){
          shareCtx.fillText('è¿˜æ²¡æœ‰æˆç»©è®°å½•', 150, 250);
        }else{
          let y = 220;
          shareCtx.fillText(`æ€»å‘æ•°: ${n}`, 150, y);
          y += 50;

          const recentStart = Math.max(0, n - 10);
          let recentSum = 0;
          for(let i = recentStart; i < n; i++) recentSum += shotScores[i];
          const recentCount = n - recentStart;

          if(recentCount === 10){
            shareCtx.fillText(`æœ€è¿‘10å‘æ€»åˆ†: ${recentSum.toFixed(1)}`, 150, y);
            y += 58;

            const title = titleByTenSum(recentSum);
            shareCtx.fillStyle = '#000';
            shareCtx.font = '900 54px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
            shareCtx.fillText(title, 150, y);
            y += 64;

            shareCtx.fillStyle = '#333';
            shareCtx.font = '800 32px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
          }

          const avg = shotScores.reduce((a,b)=>a+b,0) / n;
          shareCtx.fillText(`å¹³å‡åˆ†: ${avg.toFixed(2)}`, 150, y);
          y += 50;

          const maxScore = Math.max(...shotScores);
          shareCtx.fillText(`æœ€é«˜å•å‘: ${maxScore.toFixed(1)}`, 150, y);
        }

        shareCtx.fillStyle = '#999';
        shareCtx.font = '24px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
        shareCtx.textAlign = 'center';
        const now = new Date();
        shareCtx.fillText(now.toLocaleDateString('zh-CN'), width/2, height-40);

        shareCanvas.toBlob((blob)=>{
          if(!blob){ alert('ç”Ÿæˆå›¾ç‰‡å¤±è´¥'); return; }
          openSharePreview(blob);
        }, 'image/png');
      }catch(e){
        console.error('åˆ†äº«å¤±è´¥:', e);
        alert('åˆ†äº«åŠŸèƒ½æš‚æ—¶ä¸å¯ç”¨');
      }
    }
    shareBtn.addEventListener('click', shareScore);

    // ========================================
    // Pinch systemï¼ˆä¿æŒä½ åŸæ¥çš„å‡»å‘é€»è¾‘ï¼‰
    // ========================================
    let isPinched = false;
    let triggerLocked = false;
    const SHOT_COOLDOWN_MS = 450;
    let lastShotTs = 0;

    const PINCH_DISTANCE_ON  = 0.18;
    const PINCH_DISTANCE_OFF = 0.26;

    const PINCH_ON_FRAMES  = 2;
    const PINCH_OFF_FRAMES = 3;
    let pinchOnCount = 0;
    let pinchOffCount = 0;

    const PINCH_HISTORY_SIZE = 2;
    let pinchDistanceHistory = [];

    function addToPinchHistory(distance){
      pinchDistanceHistory.push(distance);
      if(pinchDistanceHistory.length > PINCH_HISTORY_SIZE){
        pinchDistanceHistory.shift();
      }
    }
    function getPinchDistanceSmoothed(){
      if(pinchDistanceHistory.length === 0) return 999;
      return pinchDistanceHistory.reduce((a,b)=>a+b,0) / pinchDistanceHistory.length;
    }
    function distance3D(p1, p2){
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      const dz = (p1.z || 0) - (p2.z || 0);
      return Math.sqrt(dx*dx + dy*dy + dz*dz);
    }
    function pinchRatioOf(handLm){
      const thumb = handLm[4];
      const index = handLm[8];
      const wrist = handLm[0];
      const iMcp  = handLm[5];
      const tipDist3D = distance3D(thumb, index);
      const palmSize  = Math.max(1e-6, distance3D(wrist, iMcp));
      return tipDist3D / palmSize;
    }

    function fire(isCalibrationShot){
      const now = Date.now();
      if(now - lastShotTs < SHOT_COOLDOWN_MS) return;
      if(aimX==null) return;

      lastShotTs = now;
      freezeAimX = aimX; freezeAimY = aimY;
      freezeUntil = now + FREEZE_MS;

      flashEl.style.opacity='1';
      setTimeout(()=>flashEl.style.opacity='0',80);

      beep();

      if(isCalibrationShot){
        firstShotDone = true;
        mode = MODE.PLAY;

        video.style.opacity = '0';
        video.style.pointerEvents = 'none';

        statusEl.textContent = 'æ ¡å‡†å®Œæˆ âœ… æ­£å¼å¼€å§‹';
        hintEl.textContent = 'å·¦æ‰‹"å®Œå…¨æåˆ"=å¼€æª';
        return;
      }

      const score = scoreFromAimPos(aimX, aimY);
      shotScores.push(score);
      renderScores();

      statusEl.textContent = 'READY âœ…';
      hintEl.textContent = 'å·¦æ‰‹"å®Œå…¨æåˆ"=å¼€æª';
    }

    // âœ… å…³é”®ï¼šæ›´â€œå¼ºç¡¬â€åœ°æŠŠç¬¬äºŒåªæ‰‹ä¹Ÿç”»å‡ºæ¥
    // - è‹¥æ£€æµ‹åˆ°ä¸¤åªæ‰‹ï¼šä¸€å®šåŒæ—¶ç”»ç„å‡†é•œ+æ‰³æœºï¼ˆæ— è®ºæ˜¯å¦æåˆï¼‰
    // - è‹¥åªæ£€æµ‹åˆ°ä¸€åªæ‰‹ï¼šä»ç”»ç„å‡†é•œï¼›è‹¥è¯¥æ‰‹ pinchRatio å°ï¼ˆåƒåœ¨æåˆï¼‰ä¹Ÿç”»æ‰³æœºï¼ˆè¡¥æ•‘ï¼šiOS é‡å æ—¶å¸¸åªå‡ºä¸€åªæ‰‹ï¼‰
    const TRIG_FALLBACK_RATIO = 0.42; // å•æ‰‹æ—¶ï¼špinchRatio < è¿™ä¸ªå€¼ï¼Œå°±æŠŠå®ƒä¹Ÿå½“ä½œâ€œæ‰³æœºæ‰‹â€ç”»å‡ºæ¥ï¼ˆä»…ç”¨äºæ˜¾ç¤ºï¼Œä¸ç”¨äºåˆ¤å®šâ€œåŒæ‰‹é½â€ï¼‰
    function getHandLabel(hdItem){
      return (hdItem?.label || hdItem?.classification?.[0]?.label || '');
    }

    function averageX(handLm){
      let s=0;
      for(let i=0;i<handLm.length;i++) s += handLm[i].x;
      return s / handLm.length;
    }

    function updateAimFromHand(handLm){
      const tip = handLm[8];
      const p = mapToScreen(tip.x, tip.y);
      if(aimX==null){ aimX=p.px; aimY=p.py; }
      else{
        aimX = ema(aimX, p.px, followAlpha);
        aimY = ema(aimY, p.py, followAlpha);
      }
      lastAimSeenTs = Date.now();
    }

    function updateTrigFromHand(handLm){
      const tip = handLm[8];
      const p = mapToScreen(tip.x, tip.y);
      if(trigX==null){ trigX=p.px; trigY=p.py; }
      else{
        trigX = ema(trigX, p.px, trigFollowAlpha);
        trigY = ema(trigY, p.py, trigFollowAlpha);
      }
      lastTrigSeenTs = Date.now();
    }

    // âœ… å°„å‡»ä»ç„¶åªçœ‹â€œæ‰³æœºæ‰‹â€(trigLm)åšæåˆåˆ¤æ–­
    function processTriggerHandForFire(trigLm){
      const now = Date.now();
      if(now < freezeUntil) return;
      if(!videoReady) return;

      const lThumb = trigLm[4];
      const lIndex = trigLm[8];
      const wrist  = trigLm[0];
      const iMcp   = trigLm[5];

      const tipDist3D = distance3D(lThumb, lIndex);
      const palmSize = Math.max(1e-6, distance3D(wrist, iMcp));
      const pinchRatio = tipDist3D / palmSize;

      addToPinchHistory(pinchRatio);
      const smoothedRatio = getPinchDistanceSmoothed();

      if(DEBUG_MODE){
        debugInfo.innerHTML = `
mode: ${mode}
firstShotDone: ${firstShotDone}
lockReady: ${lockReady}
aim: ${aimX? 'yes':'no'}
pinch: ${smoothedRatio.toFixed(3)}
triggerLocked: ${triggerLocked}
videoReady: ${videoReady}
holdAim: ${haveRecent(lastAimSeenTs)}
holdTrig: ${haveRecent(lastTrigSeenTs)}
        `.trim();
      }

      if(!firstShotDone && !lockReady){
        isPinched = false;
        triggerLocked = false;
        pinchOnCount = pinchOffCount = 0;
        pinchDistanceHistory = [];
        return;
      }

      if(triggerLocked){
        if(smoothedRatio > PINCH_DISTANCE_OFF){
          pinchOffCount++;
          if(pinchOffCount >= PINCH_OFF_FRAMES){
            triggerLocked = false;
            isPinched = false;
            pinchOffCount = 0;
            pinchOnCount = 0;
          }
        }else{
          pinchOffCount = 0;
        }
        return;
      }

      const isPinchConditionMet = (smoothedRatio < PINCH_DISTANCE_ON);
      const isReleaseConditionMet = (smoothedRatio > PINCH_DISTANCE_OFF);

      if(isPinchConditionMet){
        pinchOnCount++;
        pinchOffCount = 0;
      }else if(isReleaseConditionMet){
        pinchOffCount++;
        pinchOnCount = 0;
      }else{
        pinchOnCount = Math.max(0, pinchOnCount - 1);
        pinchOffCount = Math.max(0, pinchOffCount - 1);
      }

      if(!isPinched && pinchOnCount >= PINCH_ON_FRAMES){
        isPinched = true;
        pinchOnCount = 0;

        if(!firstShotDone) fire(true);
        else fire(false);

        triggerLocked = true;
        pinchOffCount = 0;
      }
    }

    function updateLockState(haveAimRecent, haveTrigRecent, haveSightRecent){
      if(!videoReady){
        lockFrames = 0;
        lockReady = false;
        firstShotDone = false;
        mode = MODE.WAIT_BOTH;
        statusEl.textContent = 'ç­‰å¾…æ‘„åƒå¤´ç”»é¢â€¦';
        hintEl.textContent = '';
        return;
      }

      // âœ… è¿™é‡Œâ€œæ˜¯å¦åŒæ‰‹éƒ½åœ¨â€ä»ç„¶ä¸¥æ ¼ä¾èµ–ï¼šçœŸçš„æœ‰ä¸¤åªæ‰‹ï¼ˆè§ onResults çš„è®¾ç½®ï¼‰
      if(!haveAimRecent || !haveTrigRecent || !haveSightRecent){
        lockFrames = 0;
        lockReady = false;

        if(firstShotDone){
          mode = MODE.PLAY;
          statusEl.textContent = 'READY âœ…';
        }else{
          mode = MODE.WAIT_BOTH;
          statusEl.textContent = 'ç­‰å¾…åŒæ‰‹...';
        }

        if(!firstShotDone){
          video.style.opacity = '0';
          video.style.pointerEvents = 'none';
        }
        return;
      }

      if(firstShotDone){
        mode = MODE.PLAY;
        lockReady = true;
        statusEl.textContent = 'READY âœ…';
        hintEl.textContent = 'å·¦æ‰‹"å®Œå…¨æåˆ"=å¼€æª';
        return;
      }

      const d = Math.hypot(aimX-cx, aimY-cy);
      const locked = d <= (LOCK_DIST_PX * DPR);
      if(locked) lockFrames++; else lockFrames=0;

      if(lockFrames >= LOCK_FRAMES_NEED){
        lockReady = true;
        mode = MODE.READY;
        statusEl.textContent = 'å·²é”å®š âœ… æ ¡å‡†å‘ä¸è®¡åˆ†';
        hintEl.textContent = 'å·¦æ‰‹éœ€è¦"å®Œå…¨æåˆ"æ‰ä¼šå‡»å‘';
      }else{
        lockReady = false;
        mode = MODE.READY;
        statusEl.textContent = locked ? `é”å®šä¸­... ${lockFrames}/${LOCK_FRAMES_NEED}` : 'è¯·å¯¹å‡†é¶å¿ƒ';
        hintEl.textContent = 'å¯¹å‡†é¶å¿ƒä¿æŒä¸€ä¸‹';
      }
    }

    // Init
    let hands=null, camera=null;

    let triedPlayOnce = false;
    async function tryPlayOnceInGesture(){
      if(triedPlayOnce) return;
      triedPlayOnce = true;
      try{
        video.muted = true;
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        await video.play();
      }catch{}
      updateVideoReady();
    }

    async function start(){
      statusEl.textContent = 'è¯·æ±‚æ‘„åƒå¤´...';
      resizeTwice();

      render();

      hands = new Hands({locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
      hands.setOptions({
        maxNumHands:2,
        modelComplexity:1,
        minDetectionConfidence:0.6,  // âœ… é™ä¸€ç‚¹ï¼šæ›´å®¹æ˜“å‡ºç¬¬äºŒåªæ‰‹
        minTrackingConfidence:0.6    // âœ… é™ä¸€ç‚¹ï¼šæ›´å®¹æ˜“æŒç»­è·Ÿè¸ª
      });

      hands.onResults(res=>{
        updateVideoReady();

        const lm = res.multiHandLandmarks||[];
        const hd = res.multiHandedness||[];

        // --- æ¸…ç†ï¼šå¦‚æœè¶…è¿‡ HOLD_MS æ‰æ¸…ç©ºï¼Œé¿å…é—ª
        if(!haveRecent(lastAimSeenTs))  aimX = aimY = null;
        if(!haveRecent(lastTrigSeenTs)) trigX = trigY = null;

        let aimLm = null;
        let trigLm = null;

        if(lm.length >= 2){
          // âœ… ä¸¤åªæ‰‹ï¼šä¸€å®šåŒæ—¶æ˜¾ç¤ºä¸¤ä¸ªç¬¦å·
          // ä¼˜å…ˆ handednessï¼›æ²¡æœ‰å°±æŒ‰â€œç”»é¢å·¦å³ä½ç½®â€åˆ†é…ï¼ˆç¨³å®šï¼‰
          let leftIdx=-1,rightIdx=-1;
          for(let i=0;i<hd.length;i++){
            const lab = getHandLabel(hd[i]);
            if(lab==='Left') leftIdx=i;
            if(lab==='Right') rightIdx=i;
          }

          if(leftIdx!==-1 && rightIdx!==-1){
            trigLm = lm[leftIdx];
            aimLm  = lm[rightIdx];
          }else{
            const ax0 = averageX(lm[0]);
            const ax1 = averageX(lm[1]);
            // x å°åœ¨ç”»é¢å·¦ä¾§ï¼ˆåŸå§‹ç›¸æœºåæ ‡ï¼‰ï¼Œç¨³å®šåšâ€œæ‰³æœºæ‰‹â€
            const idxTrig = (ax0 < ax1) ? 0 : 1;
            const idxAim  = (idxTrig===0) ? 1 : 0;
            trigLm = lm[idxTrig];
            aimLm  = lm[idxAim];
          }

          // âœ… ä¸¤ä¸ªéƒ½æ›´æ–°æ˜¾ç¤º
          if(aimLm)  updateAimFromHand(aimLm);
          if(trigLm) updateTrigFromHand(trigLm);

        }else if(lm.length === 1){
          // âœ… åªæœ‰ä¸€åªæ‰‹ï¼šæ°¸è¿œæ˜¾ç¤ºç„å‡†é•œ
          aimLm = lm[0];
          updateAimFromHand(aimLm);

          // âœ… è¡¥æ•‘ï¼šå¦‚æœè¿™åªæ‰‹æ˜æ˜¾åœ¨æåˆï¼Œå°±ä¹Ÿæ˜¾ç¤ºæ‰³æœºç¬¦å·
          // ä»…ç”¨äºâ€œè®©ç”¨æˆ·çœ‹åˆ°æåˆæ‰‹è¢«è¯†åˆ«åˆ°äº†â€ï¼Œä¸ç”¨äºåˆ¤å®šâ€œåŒæ‰‹é½â€
          const pr = pinchRatioOf(lm[0]);
          if(pr < TRIG_FALLBACK_RATIO){
            updateTrigFromHand(lm[0]);
            // æ³¨æ„ï¼šè¿™é‡Œ trigLm ä¸èµ‹å€¼ï¼ˆä¸è®©å®ƒå‚ä¸â€œåŒæ‰‹é½â€çš„é”å®šåˆ¤å®šï¼‰
          }
        }else{
          // æ²¡æœ‰æ‰‹ï¼šè®© lockState/overlay è‡ªå·±å»èµ°
        }

        const haveAimRecent  = haveRecent(lastAimSeenTs);
        const haveTrigRecent = haveRecent(lastTrigSeenTs);
        const haveSightRecent = haveAimRecent && (aimX!=null && aimY!=null);

        // âœ… å…³é”®ï¼šä¸¥æ ¼è¦æ±‚â€œçœŸçš„ä¸¤åªæ‰‹éƒ½è¢«è¯†åˆ«åˆ°â€æ‰è¿›å…¥é”å®šå¼•å¯¼
        // - è¿™é‡Œç”¨ä¸€ä¸ªé¢å¤–æ¡ä»¶ï¼šlm.length >= 2 æ‰è®¤ä¸ºâ€œåŒæ‰‹åœ¨ç›‘æ§ä¸­â€
        const bothHandsNow = (lm.length >= 2);
        const lockHaveAim = haveAimRecent;
        const lockHaveTrig = bothHandsNow && haveTrigRecent; // âœ… å•æ‰‹è¡¥æ•‘ç”»çš„æ‰³æœºï¼Œä¸ç®—â€œç¬¬äºŒåªæ‰‹åœ¨â€
        updateLockState(lockHaveAim, lockHaveTrig, haveSightRecent);

        // âœ… å¼€æªä»åªç”¨ trigLmï¼ˆçœŸæ­£çš„ç¬¬äºŒåªæ‰‹ï¼‰æ¥åˆ¤å®šæåˆ
        if(trigLm){
          processTriggerHandForFire(trigLm);
        }else{
          // æ²¡æœ‰çœŸå®æ‰³æœºæ‰‹ï¼šé‡ç½®æåˆçŠ¶æ€ï¼Œé¿å…å¡é”
          isPinched = false;
          triggerLocked = false;
          pinchOnCount = pinchOffCount = 0;
          pinchDistanceHistory = [];
        }

        render();
      });

      video.addEventListener('loadedmetadata', ()=>{ updateVideoReady(); resizeTwice(); }, {once:false});
      video.addEventListener('playing', ()=>{ updateVideoReady(); }, {once:false});

      video.style.opacity = '0';
      video.style.pointerEvents = 'none';

      firstShotDone = false;
      lockReady = false;
      lockFrames = 0;
      mode = MODE.WAIT_BOTH;

      aimX = aimY = null;
      trigX = trigY = null;
      lastAimSeenTs = 0;
      lastTrigSeenTs = 0;

      overlayMsg = '';
      overlayWanted = '';
      overlayStable = 0;

      video.style.transform = 'scaleX(-1) translateZ(0)';

      camera = new Camera(video, {
        onFrame: async()=>{
          if(!videoReady) return;
          await hands.send({image:video});
        },
        width:640, height:480, facingMode:'user'
      });

      await camera.start();

      await tryPlayOnceInGesture();

      statusEl.textContent = 'åŠ è½½æ‘„åƒå¤´ç”»é¢...';
      await waitVideoReady(9000).catch(()=>{});
      updateVideoReady();

      if(videoReady){
        statusEl.textContent = 'ç­‰å¾…åŒæ‰‹...';
      }else{
        statusEl.textContent = 'ç­‰å¾…æ‘„åƒå¤´ç”»é¢â€¦';
      }
    }

    // âœ… å¿…é¡»å…ˆç‚¹å‡»æŒ‰é’®è§£é”éŸ³é¢‘ï¼Œå†å¯åŠ¨æ‘„åƒå¤´/æ¸¸æˆ
    gateBtn.addEventListener('click', async ()=>{
      gateBtn.disabled = true;
      try{
        await enableAudio();
      }catch(e){
        console.error('enableAudio failed:', e);
        statusEl.textContent = 'å£°éŸ³å¼€å¯å¤±è´¥';
        gateBtn.disabled = false;
        return;
      }
      startGate.style.display = 'none';

      start().catch(e=>{
        console.error(e);
        statusEl.textContent='å¯åŠ¨å¤±è´¥: è¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™æˆ–HTTPSè¿æ¥';
        render();
      });
    });

    // åˆå§‹æ€
    render();
    statusEl.textContent = 'å‡†å¤‡å¼€å§‹';
  </script>
</body>
</html>
