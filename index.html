<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="format-detection" content="telephone=no,address=no,email=no">
  <title>Air Finger Rifle - Exact Logic</title>

  <style>
    html,body{margin:0;height:100%;background:#fff;overflow:hidden}
    #app{position:fixed; inset:0; display:flex; flex-direction:column; background:#fff;}
    #leftPane{
      position:relative; flex:0 0 66.6667%; min-height:0;
      background:#fff; overflow:hidden;
    }
    #rightPane{
      position:relative; flex:0 0 33.3333%; min-height:0;
      background:#fff; border-top:1px solid #eee;
      overflow:hidden; display:flex; flex-direction:column;
      padding:12px; gap:10px; box-sizing:border-box;
    }
    @media (orientation: landscape){
      #app{flex-direction:row;}
      #leftPane{flex:0 0 66.6667%; height:100vh;}
      #rightPane{
        flex:0 0 33.3333%; height:100vh;
        border-top:none; border-left:1px solid #eee;
      }
    }
    #video{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit:cover; transform:scaleX(-1); z-index:0;
      background:#000; opacity:1; transition:opacity 120ms linear;
    }
    #cv{
      position:absolute; inset:0; width:100%; height:100%;
      touch-action:none; z-index:1;
    }
    #hud{
      font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#111;background:rgba(255,255,255,.96);
      border:1px solid #ddd;border-radius:12px;padding:10px 12px;
      display:flex;gap:10px;flex-wrap:wrap;align-items:center
    }
    #hud b{font-size:15px}
    #hud .muted{color:#666}
    #hud .pill{border:1px solid #111;border-radius:999px;padding:6px 10px;background:#fff;font-weight:800}
    #hud button{appearance:none;border:1px solid #111;background:#fff;color:#111;padding:8px 10px;border-radius:10px;font-weight:800}
    #hud button:disabled{opacity:.45}
    #log{
      flex:1 1 auto; min-height:0;
      font:13px/1.35 ui-monospace,SFMono-Regular,Menlo,monospace;
      color:#111;background:rgba(255,255,255,.96);
      border:1px solid #ddd;border-radius:12px;padding:10px 12px;
      overflow:auto;white-space:pre-wrap
    }
    #flash{
      position:absolute; inset:0; z-index:2;
      background:#fff; opacity:0; pointer-events:none;
      transition:opacity 80ms linear;
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="leftPane">
      <video id="video" playsinline></video>
      <canvas id="cv"></canvas>
      <div id="flash"></div>
    </div>

    <div id="rightPane">
      <div id="hud">
        <div><b>Finger Rifle</b> <span class="muted">瞄准:右手 · 开火:左手捏合</span></div>
        <span id="status" class="pill">初始化…</span>
        <button id="btnCal">校准</button>
        <button id="btnClear">清空</button>
        <button id="btnFlip">翻转</button>
        <span class="muted" id="hint"></span>
      </div>
      <div id="log"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
    // ==========================================
    // ✅ 物理/像素 换算核心逻辑 (Strict Scale)
    // ==========================================
    
    // 1. 设定：屏幕上的黑色实心圆半径为 55px
    const VISUAL_BLACK_R_PX = 55;

    // 2. 设定：这个黑圆对应现实中的 8.0环 (分数边界)
    //    公式推导：8.0 = 10.9 - (r / 2.5)
    //    -> r = (10.9 - 8.0) * 2.5 = 2.9 * 2.5 = 7.25 mm
    const REAL_MM_AT_BLACK_EDGE = 7.25; 

    // 3. 计算比例尺：1毫米 = 多少像素
    //    Scale ≈ 7.58 px/mm
    let PIXELS_PER_MM = 1; // resize时计算
    
    // ==========================================

    const leftPane = document.getElementById('leftPane');
    const video = document.getElementById('video');
    const canvas = document.getElementById('cv');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const flashEl = document.getElementById('flash');
    const hintEl = document.getElementById('hint');
    const btnCal = document.getElementById('btnCal');
    const btnClear = document.getElementById('btnClear');
    const btnFlip = document.getElementById('btnFlip');

    let W=0,H=0,DPR=1,cx=0,cy=0;
    function resize(){
      DPR = Math.max(1, Math.floor(window.devicePixelRatio||1));
      const rect = leftPane.getBoundingClientRect();
      W = Math.max(1, Math.floor(rect.width * DPR));
      H = Math.max(1, Math.floor(rect.height * DPR));
      canvas.width = W; canvas.height = H;
      canvas.style.width = rect.width+'px';
      canvas.style.height = rect.height+'px';
      cx = W/2; cy = H/2;
      
      // 更新比例尺 (考虑DPR)
      // 这里的 VISUAL_BLACK_R_PX 是逻辑像素，乘以 DPR 得到物理像素
      PIXELS_PER_MM = (VISUAL_BLACK_R_PX * DPR) / REAL_MM_AT_BLACK_EDGE;
    }
    addEventListener('resize', resize);
    resize();

    let facingMode = 'user';
    const MODE = { WAIT_BOTH:'WAIT_BOTH', READY:'READY', CAL:'CAL' };
    let mode = MODE.WAIT_BOTH;
    const BOOT = { NEED_BOTH:'NEED_BOTH', NEED_LOCK:'NEED_LOCK', PLAY:'PLAY' };
    let bootState = BOOT.NEED_BOTH;
    let firstShotDone = false;
    let lockReady = false;

    // Visuals
    const targetSquareHalf = 120; // 白色背景大小

    // Sight
    const sight_outer_r = 130; // 外部大圆

    let trail = [];
    let aimX=null, aimY=null;
    const followAlpha = 0.90;
    let sensitivity = 2.4; 

    let calOffX = 0, calOffY = 0;
    const CAL_FRAMES_NEED = 20;
    const CAL_STABLE_RMS_PX = 6;
    let calBuf = [];
    let calOkFrames = 0;

    let isPinched = false;
    const SHOT_COOLDOWN_MS = 450;
    let lastShotTs = 0;
    const FREEZE_MS = 250;
    let freezeUntil = 0;
    let freezeAimX = null, freezeAimY = null;
    const LOCK_DIST_PX = 40;
    const LOCK_FRAMES_NEED = 24;
    let lockFrames = 0;

    // ============================================
    // ✅ 计分函数：逻辑完全换算成像素
    // ============================================
    function scoreFromDist(dpx){
      // dpx 是屏幕物理像素距离
      
      // 1. 换算成毫米
      const mm = dpx / PIXELS_PER_MM;
      
      // 2. 套用 ISSF 公式: Score = 10.9 - (r / 2.5)
      let score = 10.9 - (mm / 2.5);
      
      score = Math.max(0, Math.min(10.9, score));
      return Math.round(score * 10) / 10;
    }

    let shotScores = [];
    function renderScores(){
      let out = '';
      let total = 0;
      for(let i=0;i<shotScores.length;i++){
        out += `${i+1}. ${shotScores[i].toFixed(1)}\n`;
        total += shotScores[i];
      }
      if(shotScores.length>0){
        out = `AVG: ${(total/shotScores.length).toFixed(1)}\n\n` + out;
      }
      logEl.textContent = out;
    }

    // Utils
    const ema = (prev,next,a)=> prev + (next-prev)*a;
    function mapToScreen(nx, ny){
      let x = nx, y = ny;
      if(facingMode==='user') x = 1 - x;
      let px = x * W + calOffX;
      let py = y * H + calOffY;
      px = cx + (px - cx) * sensitivity;
      py = cy + (py - cy) * sensitivity;
      return {px,py};
    }
    function rmsDist(points){
      if(points.length<2) return 9999;
      const mx = points.reduce((s,p)=>s+p.x,0)/points.length;
      const my = points.reduce((s,p)=>s+p.y,0)/points.length;
      return Math.sqrt(points.reduce((s,p)=>s+(p.x-mx)**2+(p.y-my)**2,0)/points.length);
    }

    // Drawing
    function drawTarget(){
      ctx.clearRect(0,0,W,H);
      const half = targetSquareHalf * DPR;
      
      // 1. 靶纸白底
      ctx.fillStyle = '#fff'; ctx.fillRect(cx-half, cy-half, 2*half, 2*half);
      ctx.strokeStyle = '#000'; ctx.lineWidth = 4 * DPR;
      ctx.strokeRect(cx-half, cy-half, 2*half, 2*half);

      // 2. 绘制 8.0 环 (黑色实心圆)
      // 半径由比例尺决定: 7.25mm * PIXELS_PER_MM
      const r8 = 7.25 * PIXELS_PER_MM;
      ctx.fillStyle = '#000'; ctx.beginPath();
      ctx.arc(cx, cy, r8, 0, Math.PI*2); ctx.fill();

      // 3. 绘制 9.0 环 (辅助白线)
      // 9.0分 -> r = (10.9-9.0)*2.5 = 4.75mm
      const r9 = 4.75 * PIXELS_PER_MM;
      ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1*DPR;
      ctx.beginPath(); ctx.arc(cx, cy, r9, 0, Math.PI*2); ctx.stroke();

      // 4. 绘制 10.0 环 (关键白线)
      // 10.0分 -> r = (10.9-10.0)*2.5 = 2.25mm
      const r10 = 2.25 * PIXELS_PER_MM;
      ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.lineWidth = 1.5*DPR;
      ctx.beginPath(); ctx.arc(cx, cy, r10, 0, Math.PI*2); ctx.stroke();

      // 5. 绘制靶心点 (10.9分)
      // 实际上是个点，我们画个极小的中心点示意
      ctx.fillStyle = '#fff'; ctx.beginPath();
      ctx.arc(cx, cy, 2*DPR, 0, Math.PI*2); ctx.fill();
    }

    function drawSight(x,y){
      // 外部瞄具圈
      ctx.strokeStyle = '#000'; ctx.lineWidth = 20*DPR;
      ctx.beginPath(); ctx.arc(x,y, sight_outer_r*DPR, 0, Math.PI*2); ctx.stroke();
      
      // 准心横杠
      const barL = 30*DPR; const barH = 6*DPR;
      ctx.fillStyle = '#000';
      ctx.fillRect(x-sight_outer_r*DPR-10*DPR, y-barH/2, barL, barH);
      ctx.fillRect(x+sight_outer_r*DPR+10*DPR-barL, y-barH/2, barL, barH);
    }

    function drawTrail(){
      if(trail.length<2) return;
      ctx.lineWidth = 3*DPR; ctx.strokeStyle = 'rgba(30,136,229,0.70)';
      ctx.beginPath(); ctx.moveTo(trail[0].x, trail[0].y);
      for(let i=1;i<trail.length;i++) ctx.lineTo(trail[i].x, trail[i].y);
      ctx.stroke();
    }

    function drawHUD(haveLeft, haveRight, locked){
      const m = 20*DPR;
      const r = {x:m, y:m+60*DPR, w:W-2*m, h:H-200*DPR};
      
      if(bootState !== BOOT.PLAY){
        ctx.save();
        ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 2*DPR;
        ctx.setLineDash([8*DPR,8*DPR]); ctx.strokeRect(r.x,r.y,r.w,r.h);
        ctx.setLineDash([]);
        
        ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.font=`${14*DPR}px sans-serif`;
        ctx.textAlign='left'; ctx.fillText('左手:捏合', r.x+10, r.y+20);
        ctx.textAlign='right'; ctx.fillText('右手:瞄准', r.x+r.w-10, r.y+20);
        
        let txt = '';
        if(!haveLeft||!haveRight) txt='请双手入框';
        else if(!locked) txt='请瞄准靶心...';
        else if(!firstShotDone) txt='已锁定: 捏合左手';
        
        ctx.textAlign='center'; ctx.font=`${18*DPR}px sans-serif`;
        ctx.fillText(txt, cx, cy+140*DPR);
        ctx.restore();
      }

      if(mode===MODE.CAL){
        ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fillRect(0,0,W,H);
        ctx.fillStyle='#000'; ctx.textAlign='center'; ctx.font=`${18*DPR}px sans-serif`;
        ctx.fillText('保持瞄准靶心不动...', cx, cy-20*DPR);
        ctx.fillText(`${calOkFrames}/${CAL_FRAMES_NEED}`, cx, cy+20*DPR);
      }
    }

    function fire(){
      const now = Date.now();
      if(now - lastShotTs < SHOT_COOLDOWN_MS) return;
      if(aimX==null) return;

      const dpx = Math.hypot(aimX-cx, aimY-cy);
      const score = scoreFromDist(dpx);
      shotScores.push(score);
      renderScores();

      lastShotTs = now;
      freezeAimX = aimX; freezeAimY = aimY;
      freezeUntil = now + FREEZE_MS;
      trail = [];
      
      flashEl.style.opacity='1'; setTimeout(()=>flashEl.style.opacity='0',80);
      
      // 简单Beep
      try{
        const ac=new(window.AudioContext||window.webkitAudioContext)();
        const o=ac.createOscillator();o.frequency.value=600;
        o.connect(ac.destination);o.start();
        setTimeout(()=>{o.stop();ac.close()},50);
      }catch{}

      if(!firstShotDone && lockReady){
        firstShotDone = true;
        bootState = BOOT.PLAY;
        video.style.opacity = '0'; video.style.pointerEvents = 'none';
        statusEl.textContent = 'READY ✅';
        hintEl.textContent = '黑圆边缘=8分, 内白圈=10分';
      }
    }

    function process(l, r){
      const now = Date.now();
      if(now < freezeUntil) return;

      // Aim (Right 8)
      const aim = mapToScreen(r[8].x, r[8].y);
      if(aimX==null){ aimX=aim.px; aimY=aim.py; }
      else{ aimX=ema(aimX,aim.px,followAlpha); aimY=ema(aimY,aim.py,followAlpha); }
      if(mode===MODE.READY && bootState===BOOT.PLAY) {
        if(trail.length===0 || Math.hypot(aimX-trail[trail.length-1].x, aimY-trail[trail.length-1].y)>0.5)
          trail.push({x:aimX, y:aimY});
        if(trail.length>200) trail.shift();
      }

      // Trigger (Left 4-8 Pinch)
      const t1=mapToScreen(l[4].x, l[4].y), t2=mapToScreen(l[8].x, l[8].y);
      const dist = Math.hypot(t1.px-t2.px, t1.py-t2.py);
      const allow = (mode===MODE.READY) && (bootState===BOOT.PLAY||lockReady);
      
      if(allow){
        if(dist < 35*DPR){ if(!isPinched){ isPinched=true; fire(); } }
        else if(dist > 50*DPR) isPinched=false;
      } else isPinched=false;

      // Cal
      if(mode===MODE.CAL){
        calBuf.push({x:aim.px, y:aim.py});
        if(calBuf.length>CAL_FRAMES_NEED) calBuf.shift();
        const stable = calBuf.length>=10 && rmsDist(calBuf)<CAL_STABLE_RMS_PX*DPR;
        if(stable) calOkFrames++; else calOkFrames=0;
        if(calOkFrames>=CAL_FRAMES_NEED){
          calOffX+=(cx-aimX); calOffY+=(cy-aimY);
          mode=MODE.READY; calOkFrames=0; calBuf=[]; trail=[];
          btnCal.disabled=false;
        }
      }
    }

    function loop(l, r){
      render(l,r);
      if(l&&r) process(l,r);
      
      // Lock Logic
      if(bootState!==BOOT.PLAY){
        if(!l||!r){ bootState=BOOT.NEED_BOTH; lockFrames=0; lockReady=false; }
        else if(bootState===BOOT.NEED_BOTH) bootState=BOOT.NEED_LOCK;
        
        const d = (aimX==null)?9999:Math.hypot(aimX-cx,aimY-cy);
        if(d<(LOCK_DIST_PX*DPR)) lockFrames++; else lockFrames=0;
        
        lockReady = (lockFrames>=LOCK_FRAMES_NEED);
        if(lockReady) { statusEl.innerText='已锁定:捏合开火'; hintEl.innerText='READY TO FIRE'; }
        else statusEl.innerText='请稳定瞄准靶心...';
      }
    }

    function render(l, r){
      drawTarget();
      drawTrail();
      const now=Date.now();
      const ax=(now<freezeUntil)?freezeAimX:aimX;
      const ay=(now<freezeUntil)?freezeAimY:aimY;
      if(ax!=null) drawSight(ax, ay);
      drawHUD(l,r,lockReady);
    }

    // Init
    let hands, cam;
    async function start(){
      statusEl.innerText='启动摄像头...';
      hands = new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
      hands.setOptions({maxNumHands:2, minDetectionConfidence:0.7, minTrackingConfidence:0.7});
      hands.onResults(res=>{
        const lm=res.multiHandLandmarks, hd=res.multiHandedness;
        if(!lm||!hd){ loop(null,null); return; }
        const li=hd.findIndex(h=>h.label=='Left'), ri=hd.findIndex(h=>h.label=='Right');
        loop(li>=0?lm[li]:null, ri>=0?lm[ri]:null);
      });
      
      cam = new Camera(video, {
        onFrame:async()=>{await hands.send({image:video})},
        width:640, height:480, facingMode
      });
      await cam.start();
      mode=MODE.READY;
    }

    btnCal.onclick=()=>{mode=MODE.CAL; calOkFrames=0; btnCal.disabled=true;};
    btnClear.onclick=()=>{trail=[]; shotScores=[]; renderScores();};
    btnFlip.onclick=()=>{ location.reload(); };

    start();
  </script>
</body>
</html>
