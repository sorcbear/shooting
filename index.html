<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Air Finger Rifle - Fixed Target</title>
  <style>
    body{margin:0;background:#eee;overflow:hidden;font-family:system-ui,sans-serif}
    #app{position:fixed;inset:0;display:flex;flex-direction:column}
    #main{position:relative;flex:1;background:#fff;overflow:hidden}
    #hud{
      height:160px;background:#f8f8f8;border-top:1px solid #ccc;
      padding:10px;display:flex;flex-direction:column;gap:5px;
      z-index:10;box-shadow:0 -2px 10px rgba(0,0,0,0.05);
    }
    #video{
      position:absolute;top:0;left:0;width:100%;height:100%;
      object-fit:cover;transform:scaleX(-1);opacity:0.8;
      pointer-events:none;
    }
    canvas{position:absolute;top:0;left:0;width:100%;height:100%}
    .row{display:flex;justify-content:space-between;align-items:center}
    button{
      padding:8px 16px;background:#222;color:#fff;border:none;border-radius:6px;
      font-weight:bold;font-size:14px;
    }
    button:active{opacity:0.8}
    #scoreBoard{
      flex:1;background:#fff;border:1px solid #ddd;border-radius:6px;
      padding:8px;overflow-y:auto;font-family:monospace;font-size:13px;
      white-space:pre-wrap;
    }
    #status{font-weight:bold;color:#d32f2f}
    .flash{
      position:absolute;inset:0;background:#fff;opacity:0;pointer-events:none;
      transition:opacity 0.1s;z-index:5;
    }
  </style>
</head>
<body>

<div id="app">
  <div id="main">
    <video id="video" playsinline muted></video>
    <canvas id="cv"></canvas>
    <div id="flash" class="flash"></div>
  </div>
  
  <div id="hud">
    <div class="row">
      <span id="status">初始化中...</span>
      <div>
        <button id="btnCal">校准</button>
        <button id="btnClear">重置</button>
      </div>
    </div>
    <div id="scoreBoard">等待射击...</div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

<script>
// ================= 配置参数 =================
// 1. 物理/像素 核心换算
// 为了让手机屏幕上的体验接近真实难度，我们定义：
// 屏幕上半径 60px 的黑圆 = 现实中 7.0环 的边界 (半径 9.75mm)
// 这意味着：只要你打进黑圆内部，分数一定 > 7.0
const VISUAL_BLACK_RADIUS_PX = 60; 
const REAL_MM_AT_BLACK_EDGE = 9.75; 

// 2. 交互参数
const PINCH_TRIGGER_PX = 40; // 捏合触发像素距离
const RELEASE_TRIGGER_PX = 60; // 松开重置距离
const SENSITIVITY = 2.2; // 准心移动灵敏度

// ===========================================

const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');
const video = document.getElementById('video');
const statusEl = document.getElementById('status');
const scoreEl = document.getElementById('scoreBoard');
const flashEl = document.getElementById('flash');

let W, H, cx, cy, DPR;
let pixelsPerMm = 1; // 动态计算

// 状态变量
let aimX = null, aimY = null; // 当前准心坐标 (屏幕像素)
let trail = []; // 轨迹
let shotHistory = []; // 成绩记录

let isPinched = false;
let lastShotTime = 0;
let freezeUntil = 0;
let freezePos = null;

// 校准偏移
let calOffsetX = 0, calOffsetY = 0;
let isCalibrating = false;
let calStack = [];

// 模式
let mode = 'WAIT'; // WAIT, READY
let showCam = true;

// 1. 调整尺寸与比例尺
function resize() {
  DPR = window.devicePixelRatio || 1;
  const rect = document.getElementById('main').getBoundingClientRect();
  W = rect.width;
  H = rect.height;
  
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  ctx.scale(DPR, DPR); // 统一使用逻辑像素绘图
  
  cx = W / 2;
  cy = H / 2;
  
  // 计算比例尺： 60px / 9.75mm
  pixelsPerMm = VISUAL_BLACK_RADIUS_PX / REAL_MM_AT_BLACK_EDGE;
}
window.addEventListener('resize', resize);
resize();

// 2. 核心计分公式 (ISSF 10m Air Rifle)
function calculateScore(dx, dy) {
  // 1. 像素距离
  const distPx = Math.hypot(dx, dy);
  
  // 2. 换算为物理毫米
  const distMm = distPx / pixelsPerMm;
  
  // 3. 代入公式 Score = 10.9 - (r / 2.5)
  // 如果 r=0, 分数10.9
  // 如果 r=2.25mm (10环边界), 分数10.0
  let score = 10.9 - (distMm / 2.5);
  
  // 4. 边界修正
  score = Math.max(0, Math.min(10.9, score));
  
  return {
    score: score,
    mm: distMm
  };
}

// 3. 渲染循环 (独立于摄像头，保证靶子一直显示)
function loop() {
  ctx.clearRect(0, 0, W, H);
  
  drawTarget();
  drawTrail();
  
  const now = Date.now();
  
  // 决定显示哪个准心 (实时 vs 定格)
  let curX = aimX, curY = aimY;
  if (now < freezeUntil && freezePos) {
    curX = freezePos.x;
    curY = freezePos.y;
  }
  
  if (curX !== null && curY !== null) {
    drawSight(curX, curY);
  }
  
  if (isCalibrating) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(cx - 100, cy + 80, 200, 30);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = '14px sans-serif';
    ctx.fillText(`校准中... 保持稳定 (${calStack.length}/30)`, cx, cy + 100);
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop); // 立即启动渲染

// 4. 绘制靶子 (静态背景)
function drawTarget() {
  // 白底方块
  const size = 260;
  ctx.fillStyle = '#fff';
  ctx.fillRect(cx - size/2, cy - size/2, size, size);
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.strokeRect(cx - size/2, cy - size/2, size, size);
  
  // 黑色大圆 (7.0环边界) - 视觉锚点
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(cx, cy, VISUAL_BLACK_RADIUS_PX, 0, Math.PI * 2);
  ctx.fill();
  
  // 白色细线 (8.0环边界)
  // 8.0分 -> r = (10.9 - 8.0) * 2.5 = 7.25mm
  const r8 = 7.25 * pixelsPerMm;
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, r8, 0, Math.PI * 2);
  ctx.stroke();
  
  // 白色实线 (9.0环边界)
  // 9.0分 -> r = (10.9 - 9.0) * 2.5 = 4.75mm
  const r9 = 4.75 * pixelsPerMm;
  ctx.strokeStyle = 'rgba(255,255,255,0.8)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, r9, 0, Math.PI * 2);
  ctx.stroke();
  
  // 中心微点 (10.9)
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(cx, cy, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // 文字标注
  ctx.fillStyle = '#999';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText("ISSF 10m Air Rifle", cx, cy + size/2 + 15);
}

// 5. 绘制准心
function drawSight(x, y) {
  // 绿色准心圈
  ctx.strokeStyle = '#00E676';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y, 20, 0, Math.PI * 2); // 准心圈
  ctx.stroke();
  
  // 准心点
  ctx.fillStyle = '#D50000';
  ctx.beginPath();
  ctx.arc(x, y, 3, 0, Math.PI * 2);
  ctx.fill();
}

// 6. 绘制轨迹
function drawTrail() {
  if (trail.length < 2) return;
  ctx.strokeStyle = 'rgba(0, 230, 118, 0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(trail[0].x, trail[0].y);
  for (let i = 1; i < trail.length; i++) {
    ctx.lineTo(trail[i].x, trail[i].y);
  }
  ctx.stroke();
}

// 7. 射击逻辑
function fire() {
  if (aimX === null) return;
  const now = Date.now();
  if (now - lastShotTime < 500) return; // 冷却
  
  // 计算分数
  const result = calculateScore(aimX - cx, aimY - cy);
  const finalScore = result.score.toFixed(1);
  
  // 记录
  shotHistory.unshift(`S: ${finalScore} (偏离 ${(result.mm).toFixed(1)}mm)`);
  if (shotHistory.length > 20) shotHistory.pop();
  
  // 更新UI
  let log = shotHistory.join('\n');
  // 计算总分
  let sum = shotHistory.reduce((acc, str) => acc + parseFloat(str.split(' ')[1]), 0);
  let avg = (sum / shotHistory.length).toFixed(1);
  scoreEl.innerText = `总分: ${sum.toFixed(1)} / 均分: ${avg}\n\n` + log;
  
  // 特效
  lastShotTime = now;
  freezeUntil = now + 500; // 定格0.5秒
  freezePos = {x: aimX, y: aimY};
  trail = []; // 清空轨迹
  
  // 枪口闪光
  flashEl.style.opacity = 0.8;
  setTimeout(() => flashEl.style.opacity = 0, 50);
  
  // 如果是好成绩，震动反馈
  if (navigator.vibrate && result.score > 9.0) navigator.vibrate(50);
}

// 8. MediaPipe 处理逻辑
function onResults(results) {
  if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
    statusEl.innerText = "未检测到手";
    return;
  }
  
  statusEl.innerText = "系统正常 - 瞄准中";
  
  let leftHand = null;
  let rightHand = null;
  
  // 区分左右手
  for (const [index, landmarks] of results.multiHandLandmarks.entries()) {
    const label = results.multiHandedness[index].label;
    if (label === 'Left') leftHand = landmarks;
    if (label === 'Right') rightHand = landmarks;
  }
  
  // 1. 右手瞄准 (食指尖 8)
  if (rightHand) {
    const tip = rightHand[8];
    // 映射坐标 (0-1 -> 屏幕像素)
    // 翻转X轴因为是前置摄像头镜像
    let rawX = (1 - tip.x) * W; 
    let rawY = tip.y * H;
    
    // 应用校准偏移
    rawX += calOffsetX;
    rawY += calOffsetY;
    
    // 应用灵敏度 (相对于屏幕中心放大移动)
    const finalX = cx + (rawX - cx) * SENSITIVITY;
    const finalY = cy + (rawY - cy) * SENSITIVITY;
    
    // 平滑处理 (EMA)
    if (aimX === null) {
      aimX = finalX; aimY = finalY;
    } else {
      aimX = aimX + (finalX - aimX) * 0.8; // 0.8 响应速度
      aimY = aimY + (finalY - aimY) * 0.8;
    }
    
    // 记录轨迹
    if (!isCalibrating && Date.now() > freezeUntil) {
      trail.push({x: aimX, y: aimY});
      if (trail.length > 50) trail.shift();
    }
    
    // 校准逻辑
    if (isCalibrating) {
      calStack.push({x: finalX, y: finalY});
      if (calStack.length > 30) {
        // 计算平均值
        let sumX = 0, sumY = 0;
        calStack.forEach(p => { sumX += p.x; sumY += p.y; });
        const avgX = sumX / calStack.length;
        const avgY = sumY / calStack.length;
        
        // 计算需要的偏移量：让平均点移到中心 (cx, cy)
        // 目前点在 avgX, 想让它变成 cx
        // NewX = OldX + Offset => cx = avgX + Offset => Offset = cx - avgX
        // 注意：这里的 avgX 已经包含了旧的 offset, 所以这是增量更新
        // 为了简化，我们回退一步：
        // 实际上我们希望 Raw * Sensitivity = Center
        // 简单的做法：直接累加误差
        calOffsetX += (cx - avgX) / SENSITIVITY; 
        calOffsetY += (cy - avgY) / SENSITIVITY;
        
        isCalibrating = false;
        calStack = [];
        statusEl.innerText = "校准完成";
        trail = [];
      }
    }
  }
  
  // 2. 左手开火 (拇指4 + 食指8 距离)
  if (leftHand) {
    const t = leftHand[4];
    const i = leftHand[8];
    
    // 计算屏幕像素距离
    const dx = (t.x - i.x) * W;
    const dy = (t.y - i.y) * H;
    const dist = Math.hypot(dx, dy);
    
    if (dist < PINCH_TRIGGER_PX) {
      if (!isPinched) {
        isPinched = true;
        fire();
      }
    } else if (dist > RELEASE_TRIGGER_PX) {
      isPinched = false;
    }
  }
}

// 初始化 MediaPipe
const hands = new Hands({locateFile: (file) => {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

hands.onResults(onResults);

// 启动摄像头
const camera = new Camera(video, {
  onFrame: async () => {
    await hands.send({image: video});
  },
  width: 1280,
  height: 720
});
camera.start();

// UI 绑定
document.getElementById('btnCal').onclick = () => {
  isCalibrating = true;
  calStack = [];
};
document.getElementById('btnClear').onclick = () => {
  shotHistory = [];
  scoreEl.innerText = "等待射击...";
  calOffsetX = 0; calOffsetY = 0;
};
</script>
</body>
</html>
