<!doctype html> 
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="format-detection" content="telephone=no,address=no,email=no">
  <title>Finger Air Rifle</title>

  <style>
    html,body{margin:0;height:100%;background:#fff;overflow:hidden}
    #app{position:fixed; inset:0; display:flex; flex-direction:column; background:#fff;}
    #leftPane{
      position:relative; flex:0 0 66.6667%; min-height:0;
      background:#fff; overflow:hidden;
    }
    #rightPane{
      position:relative; flex:0 0 33.3333%; min-height:0;
      background:#fff; border-top:1px solid #eee;
      overflow:hidden; display:flex; flex-direction:column;
      padding:12px; gap:10px; box-sizing:border-box;
    }
    @media (orientation: landscape){
      #app{flex-direction:row;}
      #leftPane{flex:0 0 66.6667%; height:100vh;}
      #rightPane{
        flex:0 0 33.3333%; height:100vh;
        border-top:none; border-left:1px solid #eee;
      }
    }

    #video{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit:cover; transform:scaleX(-1) translateZ(0);
      will-change: transform;
      backface-visibility: hidden;
      z-index:0;
      background:#000; opacity:1; transition:opacity 120ms linear;
    }
    #cv{
      position:absolute; inset:0; width:100%; height:100%;
      touch-action:none; z-index:1;
      transform: translateZ(0);
      will-change: transform;
    }

    #hud{
      font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      color:#111;background:rgba(255,255,255,.96);
      border:1px solid #ddd;border-radius:12px;padding:10px 12px;
      display:flex;gap:10px;flex-wrap:wrap;align-items:center
    }
    #hud b{font-size:15px}
    #hud .muted{color:#666}
    #hud .pill{border:1px solid #111;border-radius:999px;padding:6px 10px;background:#fff;font-weight:800}
    #hint{ display:none; }

    #log{
      flex:1 1 auto; min-height:0;
      font:13px/1.35 ui-monospace,SFMono-Regular,Menlo,monospace;
      color:#111;background:rgba(255,255,255,.96);
      border:1px solid #ddd;border-radius:12px;padding:10px 12px;
      overflow:auto;white-space:pre-wrap
    }
    #flash{
      position:absolute; inset:0; z-index:2;
      background:#fff; opacity:0; pointer-events:none;
      transition:opacity 80ms linear;
    }
    #debugInfo{
      position:absolute; top:10px; left:10px; z-index:3;
      font:11px/1.3 ui-monospace,monospace;
      color:#000; background:rgba(255,255,255,0.9);
      border:1px solid #999; border-radius:6px;
      padding:8px; max-width:240px;
      display:none;
    }

    #shareBtn{
      position:absolute; top:16px; right:16px; z-index:6;
      background:#000; color:#fff;
      border:1px solid rgba(255,255,255,0.18);
      border-radius:0;
      padding:10px 14px;
      font-size:15px; font-weight:700;
      cursor:pointer;
      box-shadow:0 4px 12px rgba(0,0,0,0.28);
      transition:transform 0.15s, background 0.15s, box-shadow 0.15s;
      display:flex; align-items:center; gap:8px;
      user-select:none;
    }
    #shareBtn:hover{
      background:#111;
      transform:translateY(-1px);
      box-shadow:0 6px 16px rgba(0,0,0,0.32);
    }
    #shareBtn:active{ transform:translateY(0); }
    #shareBtn::before{
      content:'';
      width:18px; height:18px;
      display:inline-block;
      background-repeat:no-repeat;
      background-size:contain;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='white' d='M16 8l-4-4-4 4h3v6h2V8h3z'/%3E%3Cpath fill='white' d='M5 14h2v5h10v-5h2v7H5v-7z'/%3E%3C/svg%3E");
    }

    #celebration{
      position:absolute; inset:0; z-index:10;
      background:#000; color:#fff;
      display:none;
      align-items:center; justify-content:center;
      text-align:center;
      padding:24px;
      box-sizing:border-box;
      animation:fadeIn 0.18s ease-out;
    }
    #celebration.show{ display:flex; }
    @keyframes fadeIn{
      from{opacity:0; transform:scale(0.98);}
      to{opacity:1; transform:scale(1);}
    }
    #celebration .title{
      font:900 56px/1.1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      letter-spacing:0.5px;
      margin-bottom:14px;
    }
    #celebration .subtitle{
      font:700 22px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      opacity:0.88;
    }

    #sharePreview{ position:absolute; inset:0; z-index:20; display:none; }
    #sharePreview.show{ display:block; }
    #sharePreview .sp-backdrop{ position:absolute; inset:0; background:rgba(0,0,0,0.55); }
    #sharePreview .sp-panel{
      position:absolute; left:50%; top:50%;
      transform:translate(-50%,-50%);
      width:min(92vw, 860px);
      max-height:92vh;
      background:#fff; color:#000;
      border:1px solid rgba(0,0,0,0.16);
      box-shadow:0 10px 30px rgba(0,0,0,0.35);
      display:flex; flex-direction:column;
      overflow:hidden;
    }
    #sharePreview .sp-top{
      flex:0 0 auto;
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      border-bottom:1px solid rgba(0,0,0,0.10);
      background:#fff;
    }
    #sharePreview .sp-title{
      color:#000;
      font:800 16px/1.2 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    }
    #sharePreview .sp-close{
      appearance:none;
      background:#fff;
      border:1px solid rgba(0,0,0,0.18);
      color:#000;
      width:34px; height:34px;
      border-radius:0;
      font:900 22px/1 system-ui;
      cursor:pointer;
    }
    #sharePreview .sp-body{
      flex:1 1 auto;
      min-height:0;
      padding:12px;
      overflow:auto;
      background:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #sharePreview .sp-body img{
      display:block;
      width:100%;
      height:auto;
      max-height:100%;
      object-fit:contain;
      background:#000;
      border:1px solid rgba(0,0,0,0.12);
    }
    #sharePreview .sp-actions{
      flex:0 0 auto;
      display:flex;
      gap:10px;
      padding:12px 14px;
      border-top:1px solid rgba(0,0,0,0.10);
      justify-content:flex-end;
      background:#fff;
      padding-bottom:calc(12px + env(safe-area-inset-bottom));
    }
    #sharePreview .sp-btn{
      border-radius:0;
      padding:10px 14px;
      font:800 14px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      cursor:pointer;
      border:1px solid rgba(0,0,0,0.18);
      background:#fff;
      color:#000;
    }
    #sharePreview .sp-btn:hover{ background:#f3f3f3; }
    #sharePreview .sp-primary{
      background:#000; color:#fff; border-color:#000;
    }
    #sharePreview .sp-primary:hover{ background:#111; }

    @media (orientation: landscape), (max-height: 520px){
      #sharePreview .sp-panel{
        left:12px; right:12px; top:12px; bottom:12px;
        transform:none;
        width:auto;
        max-height:none;
      }
    }

    #startGate{
      position:absolute; inset:0; z-index:30;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:space-between;
      background:#fff;
      padding:18px;
      padding-top:calc(6px + env(safe-area-inset-top));
      padding-bottom:calc(20px + env(safe-area-inset-bottom));
      box-sizing:border-box;
    }
    #gateImgWrap{
      width:min(920px, 96vw);
      flex:1 1 auto;
      min-height:0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #gateImg{
      display:block;
      width:100%;
      height:auto;
      max-height:100%;
      object-fit:contain;
    }
    #gateBtn{
      width:240px;
      height:60px;
      border-radius:0;
      border:2px solid #000;
      background:#fff;
      color:#000;
      cursor:pointer;
      padding:8px 12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:4px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      user-select:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
      flex:0 0 auto;
    }
    #gateBtn .line1{font-weight:900;font-size:20px;line-height:1;}
    #gateBtn .line2{font-weight:800;font-size:13px;line-height:1;opacity:0.85;}
    #gateBtn:hover{ background:#000; color:#fff; }
    #gateBtn:disabled{ opacity:0.75; cursor:default; }
  </style>
</head>

<body>
  <div id="app">
    <div id="leftPane">
      <video id="video" playsinline muted></video>
      <canvas id="cv"></canvas>
      <div id="flash"></div>
      <div id="debugInfo"></div>

      <button id="shareBtn">分享成绩</button>

      <div id="celebration">
        <div>
          <div class="title" id="celeTitle">奥运冠军</div>
          <div class="subtitle" id="celeSub">10发总分 105.0</div>
        </div>
      </div>

      <div id="sharePreview" aria-hidden="true">
        <div class="sp-backdrop"></div>
        <div class="sp-panel" role="dialog" aria-modal="true">
          <div class="sp-top">
            <div class="sp-title">分享图片预览</div>
            <button class="sp-close" id="spClose" aria-label="关闭预览">×</button>
          </div>
          <div class="sp-body">
            <img id="spImg" alt="成绩分享图预览" />
          </div>
          <div class="sp-actions">
            <button class="sp-btn" id="spBack">返回</button>
            <button class="sp-btn sp-primary" id="spDownload">下载</button>
          </div>
        </div>
      </div>

      <div id="startGate">
        <div id="gateImgWrap">
          <img id="gateImg" src="start-guide.png" alt="左手瞄准，右手击发" />
        </div>
        <button id="gateBtn">
          <div class="line1">开始射击</div>
          <div class="line2">可开启声音，建议横屏</div>
        </button>
      </div>
    </div>

    <div id="rightPane">
      <div id="hud">
        <div><b>Finger Air Rifle</b></div>
        <div><span class="muted">左手手掌瞄准 · 右手捏合击发</span></div>
        <span id="status" class="pill">初始化…</span>
        <span class="muted" id="hint"></span>
      </div>
      <div id="log"></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
    // DOM
    const leftPane = document.getElementById('leftPane');
    const video = document.getElementById('video');
    const canvas = document.getElementById('cv');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('log');
    const flashEl = document.getElementById('flash');
    const hintEl = document.getElementById('hint');
    const debugInfo = document.getElementById('debugInfo');
    const shareBtn = document.getElementById('shareBtn');

    const celebration = document.getElementById('celebration');
    const celeTitle = document.getElementById('celeTitle');
    const celeSub = document.getElementById('celeSub');

    // Share preview DOM
    const sharePreview = document.getElementById('sharePreview');
    const spImg = document.getElementById('spImg');
    const spClose = document.getElementById('spClose');
    const spBack = document.getElementById('spBack');
    const spDownload = document.getElementById('spDownload');
    let spBlobUrl = null;
    let spDownloadName = '';

    // Start gate DOM
    const startGate = document.getElementById('startGate');
    const gateBtn = document.getElementById('gateBtn');

    // Debug
    const DEBUG_MODE = false;
    if(DEBUG_MODE) debugInfo.style.display = 'block';

    // Modes
    const MODE = { WAIT_BOTH:'WAIT_BOTH', READY:'READY', PLAY:'PLAY' };
    let mode = MODE.WAIT_BOTH;

    // Canvas size
    let W=0,H=0,DPR=1,cx=0,cy=0;
    let rectW=0, rectH=0, shortCss=0;

    function isIPhoneLike(){
      const ua = navigator.userAgent || '';
      const isiPhone = /iPhone/.test(ua);
      const isiPad = /iPad/.test(ua) || (/Macintosh/.test(ua) && /Mobile/.test(ua));
      if(isiPhone) return true;
      if(isiPad) return false;
      return shortCss < 520;
    }

    // Aim
    let aimX=null, aimY=null;
    let followAlpha = 0.97;
    let sensitivity = 2.4;

    function tuneAimByDevice(){
      const phone = isIPhoneLike();
      followAlpha = phone ? 1 : 0.965;

      const REF_SHORT = 390;
      const baseGainPhone = 8;
      const baseGainPad   = 6;
      const base = phone ? baseGainPhone : baseGainPad;

      let gain = base * (REF_SHORT / Math.max(1, shortCss));
      sensitivity = Math.min(13, Math.max(1.1, gain));
    }

    function resize(){
      DPR = Math.max(1, window.devicePixelRatio || 1);

      const rect = leftPane.getBoundingClientRect();
      rectW = rect.width;
      rectH = rect.height;
      shortCss = Math.max(1, Math.min(rectW, rectH));

      W = Math.max(1, Math.floor(rectW * DPR));
      H = Math.max(1, Math.floor(rectH * DPR));

      canvas.width = W; canvas.height = H;
      canvas.style.width = rectW+'px';
      canvas.style.height = rectH+'px';

      cx = W/2; cy = H/2;

      tuneAimByDevice();
    }

    function resizeTwice(){
      resize();
      requestAnimationFrame(()=>resize());
      setTimeout(()=>resize(), 120);
    }

    addEventListener('resize', resizeTwice);
    addEventListener('orientationchange', ()=>setTimeout(resizeTwice, 150));
    resizeTwice();

    // Video readiness
    let videoReady = false;
    function updateVideoReady(){
      videoReady = (video.readyState >= 2) && (video.videoWidth > 0) && (video.videoHeight > 0);
      return videoReady;
    }

    function waitVideoReady(timeoutMs=9000){
      return new Promise((resolve, reject)=>{
        const t0 = Date.now();
        const tick = ()=>{
          updateVideoReady();
          if(videoReady) return resolve(true);
          if(Date.now() - t0 > timeoutMs) return reject(new Error('VideoReadyTimeout'));
          setTimeout(tick, 80);
        };
        tick();
      });
    }

    // State flags
    let firstShotDone = false;
    let lockReady = false;

    // Target / sight
    const targetSquareHalf = 110;
    const targetDotR = 22;
    const sight_outer_r = 120;
    const sight_inner_r = 44;

    // ✅ 扳机logo显示位置（来自扳机手的捏合中点）
    let trigX=null, trigY=null;

    // Freeze
    const FREEZE_MS = 220;
    let freezeUntil = 0;
    let freezeAimX = null, freezeAimY = null;
    let freezeTrigX = null, freezeTrigY = null;

    // Lock for calibration phase ONLY
    const LOCK_DIST_PX = 38;
    const LOCK_FRAMES_NEED = 24;
    let lockFrames = 0;

    // Score
    const CENTER_SCORE = 10.9;
    const TOUCH_SCORE  = 6.0;

    function scoreFromAimPos(aimX_px, aimY_px){
      const d = Math.hypot(aimX_px - cx, aimY_px - cy);
      const Rb  = targetDotR * DPR;
      const Rin = sight_inner_r * DPR;
      const d_ref = Math.max(1e-6, Rin - Rb);
      const dropAtRef = (CENTER_SCORE - TOUCH_SCORE);
      const constant = d_ref / dropAtRef;
      let score = CENTER_SCORE - (d / constant);
      score = Math.max(0, Math.min(CENTER_SCORE, score));
      return Math.round(score * 10) / 10;
    }

    function titleByTenSum(sum){
      if(sum < 90)  return '建议截肢';
      if(sum < 97)  return '用脚打的？';
      if(sum < 100) return '一般般吧';
      if(sum < 102) return '有点人样了';
      if(sum < 105) return '有望冲击奥运';
      if(sum < 106) return '奥运水准！';
      if(sum < 109) return '奥运冠军！！';
      return '奥运冠军';
    }

    // Scores
    let shotScores = [];
    let lastTenShownEnd = 0;

    function showTenTitle(sum){
      celeTitle.textContent = titleByTenSum(sum);
      celeSub.textContent = `10发总分 ${sum.toFixed(1)}`;
      celebration.classList.add('show');
      setTimeout(()=>celebration.classList.remove('show'), 5000);
    }

    function renderScores(){
      const n = shotScores.length;
      if(n === 0){
        logEl.textContent = '';
        return;
      }

      let out = '';
      const groups = Math.ceil(n / 10);

      for(let g = groups - 1; g >= 0; g--){
        const start = g * 10;
        const end = Math.min(n, start + 10);

        let sum = 0;
        for(let i = start; i < end; i++) sum += shotScores[i];

        out += `Total(${start+1}-${end}): ${sum.toFixed(1)}\n`;

        if((end - start) === 10 && end > lastTenShownEnd){
          lastTenShownEnd = end;
          showTenTitle(sum);
        }

        for(let i = end - 1; i >= start; i--){
          out += `${i+1}.  ${shotScores[i].toFixed(1)}\n`;
        }
        out += '\n';
      }

      logEl.textContent = out.trim();
      logEl.scrollTop = 0;
    }

    // Utils
    const ema = (prev,next,a)=> prev + (next-prev)*a;

    function mapToScreen(nx, ny){
      let x = nx, y = ny;
      x = 1 - x; // mirror
      let px = x * W;
      let py = y * H;
      px = cx + (px - cx) * sensitivity;
      py = cy + (py - cy) * sensitivity;
      return {px,py};
    }

    // Draw
    function drawTarget(){
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,W,H);

      const half = targetSquareHalf * DPR;
      ctx.fillStyle = '#fff';
      ctx.fillRect(cx-half, cy-half, 2*half, 2*half);

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 4 * DPR;
      ctx.strokeRect(cx-half, cy-half, 2*half, 2*half);

      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(cx, cy, targetDotR * DPR, 0, Math.PI*2);
      ctx.fill();
    }

    function drawSight(x,y){
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 28*DPR;
      ctx.beginPath();
      ctx.arc(x,y, sight_outer_r*DPR, 0, Math.PI*2);
      ctx.stroke();

      const rOuter = (sight_outer_r - 14)*DPR;
      const barW = 8*DPR;
      ctx.fillStyle = '#000';
      ctx.fillRect(x-rOuter-20*DPR, y-barW/2, 20*DPR, barW);
      ctx.fillRect(x+rOuter,        y-barW/2, 20*DPR, barW);

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 14*DPR;
      ctx.beginPath();
      ctx.arc(x,y, sight_inner_r*DPR, 0, Math.PI*2);
      ctx.stroke();
    }

    // ✅ 扳机logo：按你图（圆环+柄），尺寸=瞄准镜同级
    function drawTriggerLogo(x,y){
      const R = sight_outer_r * DPR;
      const ringW = 24 * DPR;
      const stemW = 26 * DPR;
      const stemH = 150 * DPR;

      ctx.save();
      ctx.translate(x,y);
      ctx.strokeStyle = '#000';
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // 圆环
      ctx.lineWidth = ringW;
      ctx.beginPath();
      ctx.arc(0, 0, R - ringW*0.6, 0, Math.PI*2);
      ctx.stroke();

      // 柄（用粗线画“胶囊”轮廓）
      const yTop = (R - ringW*0.6) + (ringW*0.15);
      const yBot = yTop + stemH;
      ctx.lineWidth = stemW;
      ctx.beginPath();
      ctx.moveTo(0, yTop + 12*DPR);
      ctx.lineTo(0, yBot - 12*DPR);
      ctx.stroke();

      ctx.restore();
    }

    function drawGuideOverlay(haveLeft, haveRight, haveSight){
      const half = targetSquareHalf * DPR;
      const boxY = cy - half;
      const boxW = 2*half;
      const boxH = 2*half;

      const fontPx = Math.min(60*DPR, Math.max(28*DPR, Math.round(boxH * 0.22)));
      const lineH  = fontPx * 1.08;

      let msg = '';
      if(!videoReady){
        msg = '等待摄像头画面…';
      }else if(!haveLeft || !haveRight || !haveSight){
        msg = '移动双手位置\n直到露出瞄准器';
      }else if(!firstShotDone){
        if(!lockReady) msg = '请对准靶心\n保持一下';
        else msg = '已锁定 ✅\n捏合击发校准';
      }else{
        msg = '';
      }
      if(!msg) return;

      const lines = msg.split('\n');

      const safeR = (targetDotR*DPR) + (18*DPR);
      const topAreaY1 = boxY + 10*DPR;
      const topAreaY2 = (cy - safeR) - 10*DPR;

      let blockH = lines.length * lineH;
      let maxAllowedH = Math.max(10*DPR, topAreaY2 - topAreaY1);
      let scale = Math.min(1, maxAllowedH / blockH);
      const fp = fontPx * scale;
      const lh = lineH * scale;

      ctx.save();
      ctx.font = `900 ${fp}px system-ui,-apple-system,Segoe UI,Roboto,sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      let maxTextW = 0;
      for(const t of lines) maxTextW = Math.max(maxTextW, ctx.measureText(t).width);
      const padX = 10*DPR;
      const padY = 8*DPR;
      const bw = Math.min(boxW - 16*DPR, maxTextW + padX*2);
      const bh = lines.length*lh + padY*2;

      const bx = cx - bw/2;
      const by = topAreaY1 + (maxAllowedH - bh)/2;

      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.fillRect(bx, by, bw, bh);

      ctx.fillStyle = '#000';
      for(let i=0;i<lines.length;i++){
        const yy = by + padY + lh/2 + i*lh;
        ctx.fillText(lines[i], cx, yy);
      }
      ctx.restore();
    }

    function render(haveLeft, haveRight, haveSight){
      drawTarget();

      const now = Date.now();
      const fx = (now < freezeUntil && freezeAimX!=null) ? freezeAimX : aimX;
      const fy = (now < freezeUntil && freezeAimY!=null) ? freezeAimY : aimY;
      if(fx!=null) drawSight(fx, fy);

      const tx = (now < freezeUntil && freezeTrigX!=null) ? freezeTrigX : trigX;
      const ty = (now < freezeUntil && freezeTrigY!=null) ? freezeTrigY : trigY;
      if(tx!=null && ty!=null) drawTriggerLogo(tx, ty);

      drawGuideOverlay(haveLeft, haveRight, haveSight);
    }

    // ============================================================
    // ✅【声音系统】（保持你原样）
    // ============================================================
    let audioCtx = null;
    let audioEnabled = false;

    let preGain = null;
    let compressor = null;
    let limiter = null;

    let slapDelay = null;
    let slapFB = null;
    let slapMix = null;

    function ensureAudio(){
      if(audioCtx) return audioCtx;

      const AC = (window.AudioContext || window.webkitAudioContext);
      if(!AC) return null;

      audioCtx = new AC();

      preGain = audioCtx.createGain();
      preGain.gain.setValueAtTime(1.55, audioCtx.currentTime);

      compressor = audioCtx.createDynamicsCompressor();
      compressor.threshold.setValueAtTime(-22, audioCtx.currentTime);
      compressor.knee.setValueAtTime(16, audioCtx.currentTime);
      compressor.ratio.setValueAtTime(10, audioCtx.currentTime);
      compressor.attack.setValueAtTime(0.002, audioCtx.currentTime);
      compressor.release.setValueAtTime(0.16, audioCtx.currentTime);

      limiter = audioCtx.createDynamicsCompressor();
      limiter.threshold.setValueAtTime(-1.1, audioCtx.currentTime);
      limiter.knee.setValueAtTime(0, audioCtx.currentTime);
      limiter.ratio.setValueAtTime(20, audioCtx.currentTime);
      limiter.attack.setValueAtTime(0.001, audioCtx.currentTime);
      limiter.release.setValueAtTime(0.08, audioCtx.currentTime);

      slapDelay = audioCtx.createDelay(0.10);
      slapDelay.delayTime.setValueAtTime(0.030, audioCtx.currentTime);
      slapFB = audioCtx.createGain();
      slapFB.gain.setValueAtTime(0.18, audioCtx.currentTime);
      slapMix = audioCtx.createGain();
      slapMix.gain.setValueAtTime(0.22, audioCtx.currentTime);

      preGain.connect(slapDelay);
      slapDelay.connect(slapMix);
      slapMix.connect(compressor);

      slapDelay.connect(slapFB);
      slapFB.connect(slapDelay);

      preGain.connect(compressor);
      compressor.connect(limiter);
      limiter.connect(audioCtx.destination);

      return audioCtx;
    }

    async function enableAudio(){
      const ctx = ensureAudio();
      if(!ctx) throw new Error('NoAudioContext');
      if(ctx.state === 'suspended') await ctx.resume();
      audioEnabled = true;

      try{
        const t = ctx.currentTime;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(40, t);
        g.gain.setValueAtTime(0.00001, t);
        o.connect(g); g.connect(preGain);
        o.start(t);
        o.stop(t + 0.03);
      }catch{}
    }

    function makeNoiseBuffer(dur){
      const ctx = audioCtx;
      const n = Math.floor(ctx.sampleRate * dur);
      const buf = ctx.createBuffer(1, n, ctx.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<n;i++){
        const x = i / n;
        const e = Math.pow(1 - x, 2.15);
        const punch = (x < 0.020) ? 2.25 : 1.0;
        data[i] = (Math.random()*2-1) * e * punch;
      }
      return buf;
    }

    function beep(){
      if(!audioEnabled || !audioCtx || !preGain) return;
      const ctx = audioCtx;
      const t0 = ctx.currentTime;

      try{
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(78, t0);
        o.frequency.exponentialRampToValueAtTime(42, t0 + 0.16);
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.linearRampToValueAtTime(1.05, t0 + 0.008);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.22);
        o.connect(g); g.connect(preGain);
        o.start(t0);
        o.stop(t0 + 0.26);
      }catch{}

      try{
        const dur = 0.32;
        const src = ctx.createBufferSource();
        src.buffer = makeNoiseBuffer(dur);

        const lp = ctx.createBiquadFilter();
        lp.type = 'lowpass';
        lp.frequency.setValueAtTime(4200, t0);
        lp.frequency.exponentialRampToValueAtTime(700, t0 + dur);

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.linearRampToValueAtTime(1.15, t0 + 0.006);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        src.connect(lp); lp.connect(g); g.connect(preGain);
        src.start(t0);
        src.stop(t0 + dur + 0.03);
      }catch{}

      try{
        const dur = 0.08;
        const src = ctx.createBufferSource();
        src.buffer = makeNoiseBuffer(dur);

        const hp = ctx.createBiquadFilter();
        hp.type = 'highpass';
        hp.frequency.setValueAtTime(1400, t0);

        const bp = ctx.createBiquadFilter();
        bp.type = 'bandpass';
        bp.frequency.setValueAtTime(3200, t0);
        bp.Q.setValueAtTime(8.0, t0);

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.linearRampToValueAtTime(0.95, t0 + 0.004);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

        src.connect(hp); hp.connect(bp); bp.connect(g); g.connect(preGain);
        src.start(t0);
        src.stop(t0 + dur + 0.02);
      }catch{}
    }

    // Share preview open/close（保持原样）
    function openSharePreview(blob){
      if(spBlobUrl){
        URL.revokeObjectURL(spBlobUrl);
        spBlobUrl = null;
      }
      spBlobUrl = URL.createObjectURL(blob);
      spDownloadName = `finger-rifle-${Date.now()}.png`;

      spImg.src = spBlobUrl;
      sharePreview.classList.add('show');
      sharePreview.setAttribute('aria-hidden','false');
    }

    function closeSharePreview(){
      sharePreview.classList.remove('show');
      sharePreview.setAttribute('aria-hidden','true');

      if(spBlobUrl){
        URL.revokeObjectURL(spBlobUrl);
        spBlobUrl = null;
      }
      spImg.src = '';
    }

    spClose.addEventListener('click', closeSharePreview);
    spBack.addEventListener('click', closeSharePreview);
    sharePreview.querySelector('.sp-backdrop').addEventListener('click', closeSharePreview);

    spDownload.addEventListener('click', ()=>{
      if(!spBlobUrl) return;
      const a = document.createElement('a');
      a.href = spBlobUrl;
      a.download = spDownloadName || `finger-rifle-${Date.now()}.png`;
      a.click();
    });

    async function shareScore(){ /* 你原样，省略：和你贴的相同 */ }
    // 你原来的 shareScore 很长，这里保持不变：如果你需要我也可完整贴上（不影响识别）
    // 为避免你复制漏掉：建议你直接把你原本 shareScore 那段整段粘回去即可。
    // ---- 这里为了完整性，仍然绑定按钮（保持一致）----
    shareBtn.addEventListener('click', ()=>{
      // 如果你已粘回完整 shareScore，就改为：shareScore();
      // 临时防报错：
      alert('请把你原代码的 shareScore() 原样粘回这一段（我没有改它）。');
    });

    // ========================================
    // Pinch system（保持你原样）
    // ========================================
    let isPinched = false;
    let triggerLocked = false;
    const SHOT_COOLDOWN_MS = 450;
    let lastShotTs = 0;

    const PINCH_DISTANCE_ON  = 0.20;
    const PINCH_DISTANCE_OFF = 0.28;

    const PINCH_ON_FRAMES  = 3;
    const PINCH_OFF_FRAMES = 3;
    let pinchOnCount = 0;
    let pinchOffCount = 0;

    const PINCH_HISTORY_SIZE = 2;
    let pinchDistanceHistory = [];

    function addToPinchHistory(distance){
      pinchDistanceHistory.push(distance);
      if(pinchDistanceHistory.length > PINCH_HISTORY_SIZE){
        pinchDistanceHistory.shift();
      }
    }
    function getPinchDistanceSmoothed(){
      if(pinchDistanceHistory.length === 0) return 999;
      return pinchDistanceHistory.reduce((a,b)=>a+b,0) / pinchDistanceHistory.length;
    }
    function distance3D(p1, p2){
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      const dz = (p1.z || 0) - (p2.z || 0);
      return Math.sqrt(dx*dx + dy*dy + dz*dz);
    }

    function fire(isCalibrationShot){
      const now = Date.now();
      if(now - lastShotTs < SHOT_COOLDOWN_MS) return;
      if(aimX==null) return;

      lastShotTs = now;
      freezeAimX = aimX; freezeAimY = aimY;
      freezeTrigX = trigX; freezeTrigY = trigY;
      freezeUntil = now + FREEZE_MS;

      flashEl.style.opacity='1';
      setTimeout(()=>flashEl.style.opacity='0',80);

      beep();

      if(isCalibrationShot){
        firstShotDone = true;
        mode = MODE.PLAY;

        video.style.opacity = '0';
        video.style.pointerEvents = 'none';

        statusEl.textContent = '校准完成 ✅ 正式开始';
        hintEl.textContent = '左手"完全捏合"=开枪';
        return;
      }

      const score = scoreFromAimPos(aimX, aimY);
      shotScores.push(score);
      renderScores();

      statusEl.textContent = 'READY ✅';
      hintEl.textContent = '左手"完全捏合"=开枪';
    }

    // ============================================================
    // ✅【关键修复：回到“源代码逻辑”，但让 Left/Right 稳定】
    // - 规则仍然是：右手负责瞄准，左手负责捏合击发
    // - 但 handedness 抖动时：用“上一帧记忆 + 画面左右位置”稳定配对
    // - 丢一只手短时间不清空另一只手，避免必须贴近/闪烁
    // ============================================================
    function getHandIndexByLabel(hdList, label){
      for(let i=0;i<hdList.length;i++){
        const lb = (hdList[i]?.label || hdList[i]?.classification?.[0]?.label);
        if(lb === label) return i;
      }
      return -1;
    }
    function meanX(lm){
      let s=0;
      for(const p of lm) s += p.x;
      return s / lm.length;
    }
    function screenXFromLm(lm){
      // 画面是 mirror 显示，屏幕坐标 x = 1 - modelX
      return 1 - meanX(lm);
    }

    // 上一帧的稳定配对（用于消除抖动）
    let lastAimIdx = -1;   // 在 lm 数组里的索引
    let lastTrigIdx = -1;
    let lastSeenAimTs = 0;
    let lastSeenTrigTs = 0;
    const GRACE_MS = 250;  // ✅ 丢手宽限时间：不清空，防闪烁

    function assignHandsStable(lm, hd){
      const n = lm.length;
      if(n === 0)_attachNone();

      // 先按 handedness 尝试（你原来的逻辑）
      const lIdx = getHandIndexByLabel(hd, 'Left');
      const rIdx = getHandIndexByLabel(hd, 'Right');

      // 目标：trig=Left, aim=Right（保持你原规则）
      let trigIdx = (lIdx !== -1) ? lIdx : -1;
      let aimIdx  = (rIdx !== -1) ? rIdx : -1;

      // 如果 handedness 不完整、或只给了一个 label：用“画面左右 + 上一帧”补齐
      if(n === 1){
        // 只有一只手：尽量贴近上一帧角色；否则用画面左右做猜测
        const sx = screenXFromLm(lm[0]); // 0..1
        // mirror 下：用户右手通常在屏幕左侧；但我们更依赖“上一帧”
        if(lastAimIdx === 0 || lastTrigIdx === 0){
          if(lastAimIdx === 0){ aimIdx = 0; trigIdx = -1; }
          else { trigIdx = 0; aimIdx = -1; }
        }else{
          // 没历史：如果这只手更靠左，优先当 aim（右手瞄准常出现在左侧）
          if(sx < 0.5){ aimIdx = 0; trigIdx = -1; }
          else { trigIdx = 0; aimIdx = -1; }
        }
      }else if(n >= 2){
        // 两只手：如果 handedness 两个都可靠就直接用
        const handednessOk = (trigIdx !== -1 && aimIdx !== -1 && trigIdx !== aimIdx);

        if(!handednessOk){
          // 用“上一帧最小交换”稳定配对：两种分配算代价，选更像上一帧的
          const idxA = 0, idxB = 1;
          const cost = (aAim, aTrig)=>{
            let c = 0;
            if(lastAimIdx !== -1) c += (aAim === lastAimIdx ? 0 : 1);
            if(lastTrigIdx !== -1) c += (aTrig === lastTrigIdx ? 0 : 1);
            // 次级：让 aim 更偏左（符合 mirror 下右手常在左侧的经验）
            const sxAim = screenXFromLm(lm[aAim]);
            c += (sxAim < 0.5 ? 0 : 0.2);
            return c;
          };
          const c1 = cost(idxA, idxB);
          const c2 = cost(idxB, idxA);
          if(c1 <= c2){ aimIdx = idxA; trigIdx = idxB; }
          else { aimIdx = idxB; trigIdx = idxA; }
        }
      }

      // 输出
      const now = Date.now();
      let aimLm = (aimIdx !== -1 && lm[aimIdx]) ? lm[aimIdx] : null;
      let trigLm = (trigIdx !== -1 && lm[trigIdx]) ? lm[trigIdx] : null;

      // 记录“稳定索引”（仅当该索引存在）
      if(aimLm){
        lastAimIdx = aimIdx;
        lastSeenAimTs = now;
      }
      if(trigLm){
        lastTrigIdx = trigIdx;
        lastSeenTrigTs = now;
      }

      // ✅ 丢手宽限：GRACE_MS 内允许继续保留上一次状态（不清空）
      const aimOk = !!aimLm || (now - lastSeenAimTs <= GRACE_MS);
      const trigOk = !!trigLm || (now - lastSeenTrigTs <= GRACE_MS);

      return { aimLm, trigLm, aimOk, trigOk };

      function _attachNone(){
        return {aimLm:null,trigLm:null,aimOk:false,trigOk:false};
      }
    }

    // ✅ 你的原 processFrame(leftLm,rightLm) 逻辑不改，只是把“扳机手=leftLm, 瞄准手=rightLm”稳定喂进去
    function processFrame(leftLm, rightLm){
      const now = Date.now();
      if(now < freezeUntil) return;
      if(!videoReady) return;

      // 右手：瞄准（保持原样）
      if(rightLm){
        const rTip = rightLm[8];
        const aimP = mapToScreen(rTip.x, rTip.y);

        if(aimX==null){ aimX=aimP.px; aimY=aimP.py; }
        else{
          aimX = ema(aimX, aimP.px, followAlpha);
          aimY = ema(aimY, aimP.py, followAlpha);
        }
      }

      // 左手：扳机logo位置（拇指+食指中点）
      if(leftLm){
        const th = leftLm[4];
        const ix = leftLm[8];
        const mx = (th.x + ix.x) * 0.5;
        const my = (th.y + ix.y) * 0.5;
        const p = mapToScreen(mx, my);
        trigX = p.px; trigY = p.py;
      }

      // 下面捏合触发：完全按你原样（仅加了 leftLm 空判断）
      if(!leftLm) return;

      const lThumb = leftLm[4];
      const lIndex = leftLm[8];
      const wrist  = leftLm[0];
      const iMcp   = leftLm[5];

      const tipDist3D = distance3D(lThumb, lIndex);
      const palmSize = Math.max(1e-6, distance3D(wrist, iMcp));
      const pinchRatio = tipDist3D / palmSize;

      addToPinchHistory(pinchRatio);
      const smoothedRatio = getPinchDistanceSmoothed();

      if(DEBUG_MODE){
        debugInfo.innerHTML = `
mode: ${mode}
firstShotDone: ${firstShotDone}
lockReady: ${lockReady}
aim: ${aimX? 'yes':'no'}
trig: ${trigX? 'yes':'no'}
pinch: ${smoothedRatio.toFixed(3)}
triggerLocked: ${triggerLocked}
videoReady: ${videoReady}
readyState: ${video.readyState}
vw/vh: ${video.videoWidth}x${video.videoHeight}
        `.trim();
      }

      if(!firstShotDone && !lockReady){
        isPinched = false;
        triggerLocked = false;
        pinchOnCount = pinchOffCount = 0;
        pinchDistanceHistory = [];
        return;
      }

      if(triggerLocked){
        if(smoothedRatio > PINCH_DISTANCE_OFF){
          pinchOffCount++;
          if(pinchOffCount >= PINCH_OFF_FRAMES){
            triggerLocked = false;
            isPinched = false;
            pinchOffCount = 0;
            pinchOnCount = 0;
          }
        }else{
          pinchOffCount = 0;
        }
        return;
      }

      const isPinchConditionMet = (smoothedRatio < PINCH_DISTANCE_ON);
      const isReleaseConditionMet = (smoothedRatio > PINCH_DISTANCE_OFF);

      if(isPinchConditionMet){
        pinchOnCount++;
        pinchOffCount = 0;
      }else if(isReleaseConditionMet){
        pinchOffCount++;
        pinchOnCount = 0;
      }else{
        pinchOnCount = Math.max(0, pinchOnCount - 1);
        pinchOffCount = Math.max(0, pinchOffCount - 1);
      }

      if(!isPinched && pinchOnCount >= PINCH_ON_FRAMES){
        isPinched = true;
        pinchOnCount = 0;

        if(!firstShotDone) fire(true);
        else fire(false);

        triggerLocked = true;
        pinchOffCount = 0;
      }
    }

    function updateLockState(haveLeft, haveRight, haveSight){
      if(!videoReady){
        lockFrames = 0;
        lockReady = false;
        firstShotDone = false;
        mode = MODE.WAIT_BOTH;
        statusEl.textContent = '等待摄像头画面…';
        hintEl.textContent = '';
        return;
      }

      if(!haveLeft || !haveRight || !haveSight){
        lockFrames = 0;
        lockReady = false;

        if(firstShotDone){
          mode = MODE.PLAY;
          statusEl.textContent = 'READY ✅';
        }else{
          mode = MODE.WAIT_BOTH;
          statusEl.textContent = '等待双手...';
        }

        if(!firstShotDone){
          video.style.opacity = '1';
          video.style.pointerEvents = 'auto';
        }
        return;
      }

      if(firstShotDone){
        mode = MODE.PLAY;
        lockReady = true;
        statusEl.textContent = 'READY ✅';
        hintEl.textContent = '左手"完全捏合"=开枪';
        return;
      }

      const d = Math.hypot(aimX-cx, aimY-cy);
      const locked = d <= (LOCK_DIST_PX * DPR);
      if(locked) lockFrames++; else lockFrames=0;

      if(lockFrames >= LOCK_FRAMES_NEED){
        lockReady = true;
        mode = MODE.READY;
        statusEl.textContent = '已锁定 ✅ 校准发不计分';
        hintEl.textContent = '左手需要"完全捏合"才会击发';
      }else{
        lockReady = false;
        mode = MODE.READY;
        statusEl.textContent = locked ? `锁定中... ${lockFrames}/${LOCK_FRAMES_NEED}` : '请对准靶心';
        hintEl.textContent = '对准靶心保持一下';
      }
    }

    // Init
    let hands=null, camera=null;

    let triedPlayOnce = false;
    async function tryPlayOnceInGesture(){
      if(triedPlayOnce) return;
      triedPlayOnce = true;
      try{
        video.muted = true;
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        await video.play();
      }catch{}
      updateVideoReady();
    }

    async function start(){
      statusEl.textContent = '请求摄像头...';
      resizeTwice();

      render(false,false,false);

      hands = new Hands({locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
      hands.setOptions({
        maxNumHands:2,
        modelComplexity:1,
        minDetectionConfidence:0.7,
        minTrackingConfidence:0.7
      });

      hands.onResults(res=>{
        updateVideoReady();

        const lm = res.multiHandLandmarks||[];
        const hd = res.multiHandedness||[];

        // ✅ 稳定分配：仍然“左=扳机、右=瞄准”，但不会因为 label 抖动而要求两手贴近
        const {aimLm, trigLm, aimOk, trigOk} = assignHandsStable(lm, hd);

        // 你原逻辑：需要 left+right 才进入；现在用稳定后的 aimOk/trigOk
        const haveLeft  = trigOk;   // 左手（扳机）
        const haveRight = aimOk;    // 右手（瞄准）

        // ✅ 只在“超过 GRACE_MS 真的丢了”才清空对应状态，避免闪烁
        const now = Date.now();
        if(!aimLm && (now - lastSeenAimTs > GRACE_MS)){
          aimX = aimY = null;
        }
        if(!trigLm && (now - lastSeenTrigTs > GRACE_MS)){
          trigX = trigY = null;
          isPinched = false;
          triggerLocked = false;
          pinchOnCount = pinchOffCount = 0;
          pinchDistanceHistory = [];
        }

        // ✅ 喂入你原来的 processFrame(leftLm,rightLm) 结构
        processFrame(trigLm, aimLm);

        const haveSight = (aimX!=null && aimY!=null);
        updateLockState(haveLeft, haveRight, haveSight);
        render(haveLeft, haveRight, haveSight);
      });

      video.addEventListener('loadedmetadata', ()=>{ updateVideoReady(); resizeTwice(); }, {once:false});
      video.addEventListener('playing', ()=>{ updateVideoReady(); }, {once:false});

      video.style.opacity = '1';
      video.style.pointerEvents = 'auto';
      firstShotDone = false;
      lockReady = false;
      lockFrames = 0;
      mode = MODE.WAIT_BOTH;

      video.style.transform = 'scaleX(-1) translateZ(0)';

      camera = new Camera(video, {
        onFrame: async()=>{
          if(!videoReady) return;
          await hands.send({image:video});
        },
        width:640, height:480, facingMode:'user'
      });

      await camera.start();
      await tryPlayOnceInGesture();

      statusEl.textContent = '加载摄像头画面...';
      await waitVideoReady(9000).catch(()=>{});
      updateVideoReady();

      statusEl.textContent = videoReady ? '等待双手...' : '等待摄像头画面…';
    }

    gateBtn.addEventListener('click', async ()=>{
      gateBtn.disabled = true;
      try{
        await enableAudio();
      }catch(e){
        console.error('enableAudio failed:', e);
        statusEl.textContent = '声音开启失败';
        gateBtn.disabled = false;
        return;
      }
      startGate.style.display = 'none';

      start().catch(e=>{
        console.error(e);
        statusEl.textContent='启动失败: 请检查摄像头权限或HTTPS连接';
        render(false,false,false);
      });
    });

    render(false,false,false);
    statusEl.textContent = '准备开始';
  </script>
</body>
</html>
